<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · A Julia package for computational (bio)mechanics and computational design</title><meta name="title" content="Functions · A Julia package for computational (bio)mechanics and computational design"/><meta property="og:title" content="Functions · A Julia package for computational (bio)mechanics and computational design"/><meta property="twitter:title" content="Functions · A Julia package for computational (bio)mechanics and computational design"/><meta name="description" content="Documentation for A Julia package for computational (bio)mechanics and computational design."/><meta property="og:description" content="Documentation for A Julia package for computational (bio)mechanics and computational design."/><meta property="twitter:description" content="Documentation for A Julia package for computational (bio)mechanics and computational design."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>A Julia package for computational (bio)mechanics and computational design</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#comododir"><span><code>comododir</code></span></a></li><li><a class="tocitem" href="#slidercontrol"><span><code>slidercontrol</code></span></a></li><li><a class="tocitem" href="#elements2indices"><span><code>elements2indices</code></span></a></li><li><a class="tocitem" href="#gridpoints"><span><code>gridpoints</code></span></a></li><li><a class="tocitem" href="#interp_biharmonic_spline"><span><code>interp_biharmonic_spline</code></span></a></li><li><a class="tocitem" href="#interp_biharmonic"><span><code>interp_biharmonic</code></span></a></li><li><a class="tocitem" href="#nbezier"><span><code>nbezier</code></span></a></li><li><a class="tocitem" href="#loflinear"><span><code>loflinear</code></span></a></li><li><a class="tocitem" href="#ray_triangle_intersect"><span><code>ray_triangle_intersect</code></span></a></li><li><a class="tocitem" href="#mesh_curvature_polynomial"><span><code>mesh_curvature_polynomial</code></span></a></li><li><a class="tocitem" href="#smoothmesh_hc"><span><code>smoothmesh_hc</code></span></a></li><li><a class="tocitem" href="#smoothmesh_laplacian"><span><code>smoothmesh_laplacian</code></span></a></li><li><a class="tocitem" href="#platonicsolid"><span><code>platonicsolid</code></span></a></li><li><a class="tocitem" href="#sub2ind"><span><code>sub2ind</code></span></a></li><li><a class="tocitem" href="#ind2sub"><span><code>ind2sub</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/COMODO-research/Comodo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/COMODO-research/Comodo.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="comododir"><a class="docs-heading-anchor" href="#comododir"><code>comododir</code></a><a id="comododir-1"></a><a class="docs-heading-anchor-permalink" href="#comododir" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.comododir" href="#Comodo.comododir"><code>Comodo.comododir</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">comododir()</code></pre><p><strong>Description</strong></p><p>This function simply returns the string for the Comodo path. This is helpful for instance to load items, such as meshes, from the <code>assets</code>` folder. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L36-L42">source</a></section></article><h2 id="slidercontrol"><a class="docs-heading-anchor" href="#slidercontrol"><code>slidercontrol</code></a><a id="slidercontrol-1"></a><a class="docs-heading-anchor-permalink" href="#slidercontrol" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.slidercontrol" href="#Comodo.slidercontrol"><code>Comodo.slidercontrol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">slidercontrol(hSlider,ax)</code></pre><p><strong>Description</strong></p><p>This function adds arrow key control to GLMakie sliders. The inputs are the  slider handle <code>hSlider</code> as well as the axis <code>ax</code>. If this function is called the slider can be advanced a step by pressing the right arrow, and returned one step  by pressing the left arrow. When one presses and holds the right or left arrow  key, the slider will continue to move (as fast as graphics updating is possible on your system) up to the end or start slider position respectively. Users may  also use the up or down arrow keys. These function the same as the right and  left arrow keys, however, rather than stopping at the slider extrema, the  sliders position will &quot;wrap&quot; back to the start when advancing beyond the end  position, and vice versa. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L48-L63">source</a></section></article><h2 id="elements2indices"><a class="docs-heading-anchor" href="#elements2indices"><code>elements2indices</code></a><a id="elements2indices-1"></a><a class="docs-heading-anchor-permalink" href="#elements2indices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.elements2indices" href="#Comodo.elements2indices"><code>Comodo.elements2indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elements2indices(F)</code></pre><p><strong>Description</strong></p><p>This function obtains the unique set of indices for the vertices (nodes)  used by the the simplices defined by <code>F</code>. The vector <code>F</code> may contain any type of  simplices. For instance the elements in <code>F</code> may be of the type  <code>GeometryBasics.TriangleFace</code> or <code>GeometryBasics.QuadFace</code> (or any other) for  surface mesh data. However, volumetric elements of any type are permitted. In essence this function simply returns <code>unique(reduce(vcat,F))</code>. Hence any suitable vector containing vectors of numbers permitted by  <code>reduce(vcat,F)</code> is supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L97-L110">source</a></section></article><h2 id="gridpoints"><a class="docs-heading-anchor" href="#gridpoints"><code>gridpoints</code></a><a id="gridpoints-1"></a><a class="docs-heading-anchor-permalink" href="#gridpoints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.gridpoints" href="#Comodo.gridpoints"><code>Comodo.gridpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gridpoints(x::Vector{T}, y=x, z=x) where T&lt;:Real</code></pre><p><strong>Description</strong></p><p>The <code>gridpoints</code> function returns a vector of 3D points which span a grid in 3D  space. Points are defined as per the input ranges or range vectors. The output  point vector contains elements of the type <code>GeometryBasics.Point3</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L115-L123">source</a></section></article><h2 id="interp_biharmonic_spline"><a class="docs-heading-anchor" href="#interp_biharmonic_spline"><code>interp_biharmonic_spline</code></a><a id="interp_biharmonic_spline-1"></a><a class="docs-heading-anchor-permalink" href="#interp_biharmonic_spline" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.interp_biharmonic_spline" href="#Comodo.interp_biharmonic_spline"><code>Comodo.interp_biharmonic_spline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interp_biharmonic_spline(x::Union{Vector{T}, AbstractRange{T}},y::Union{Vector{T}, AbstractRange{T}},xi::Union{Vector{T}, AbstractRange{T}}; extrapolate_method=:linear,pad_data=:linear) where T&lt;:Real</code></pre><p><strong>Description</strong></p><p>This function uses biharmonic spline interpolation, which features radial basis  functions. The input is assumed to represent ordered data, i.e. consequtive  unique points on a curve. The curve x-, and y-coordinates are provided through  the input parameters <code>x</code> and <code>y</code> respectively. The third input <code>xi</code> defines the  sites at which to interpolate. Each of in the input parameters can be either a  vector or a range. </p><p><strong>References</strong></p><p><a href="https://doi.org/10.1029/GL014i002p00139">David T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L129-L143">source</a></section></article><h2 id="interp_biharmonic"><a class="docs-heading-anchor" href="#interp_biharmonic"><code>interp_biharmonic</code></a><a id="interp_biharmonic-1"></a><a class="docs-heading-anchor-permalink" href="#interp_biharmonic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.interp_biharmonic" href="#Comodo.interp_biharmonic"><code>Comodo.interp_biharmonic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interp_biharmonic(x,y,xi)</code></pre><p><strong>Description</strong></p><p>This function uses biharmonic interpolation. The input <code>x</code> should define a  vector consisting of m points which are n-dimensional, and the input <code>y</code> should be a vector consisting of m scalar data values. </p><p><strong>References</strong></p><p><a href="https://doi.org/10.1029/GL014i002p00139">David T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L234-L246">source</a></section></article><h2 id="nbezier"><a class="docs-heading-anchor" href="#nbezier"><code>nbezier</code></a><a id="nbezier-1"></a><a class="docs-heading-anchor-permalink" href="#nbezier" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.nbezier" href="#Comodo.nbezier"><code>Comodo.nbezier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nbezier(P,n)</code></pre><p><strong>Description</strong></p><p>This function returns <code>n</code> points for an m-th order Bézier spline, based on the  m control points contained in the input vector <code>P</code>. This function supports point vectors with elements of the type <code>AbstractPoint{3}</code> (e.g. <code>GeometryBasics.Point{3, Float64}</code>) or <code>Vector{Float64}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L264-L273">source</a></section></article><h2 id="loflinear"><a class="docs-heading-anchor" href="#loflinear"><code>loflinear</code></a><a id="loflinear-1"></a><a class="docs-heading-anchor-permalink" href="#loflinear" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.loftlinear" href="#Comodo.loftlinear"><code>Comodo.loftlinear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loftlinear(V1,V2;num_steps=2,close_loop=true,face_type=:tri)</code></pre><p>Loft a surface mesh between two input curves</p><p><strong>Description</strong></p><p>The <code>loftlinear</code> function spans a surface from input curve <code>V1</code> to curve <code>V2</code>.  The surface is formed by &quot;lerping&quot; curves from <code>V1</code> to <code>V2</code> in <code>num_loft</code>  steps, and forming mesh faces between each curve. If <code>close_loop==true</code> then it is assumed the curves (and therefore the output surface mesh should be  closed over, i.e. that a connection should be made between each curve end and  start point. The user can request different face types for the output. The  default is <code>face_type=:tri</code> which will form isoceles triangles (or equilateral  triangles if the spacing is even) for a planar curve. The other <code>face_type</code> options supported are <code>:quad</code> (quadrilateral), and <code>:tri_slash</code>. For the  latter, triangles are formed by slashing the quads.  </p><p><strong>Arguments:</strong></p><ul><li><code>V1::Vector</code>: n-vector </li><li><code>V2::Vector</code>: n-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L1933-L1955">source</a></section></article><h2 id="ray_triangle_intersect"><a class="docs-heading-anchor" href="#ray_triangle_intersect"><code>ray_triangle_intersect</code></a><a id="ray_triangle_intersect-1"></a><a class="docs-heading-anchor-permalink" href="#ray_triangle_intersect" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.ray_triangle_intersect" href="#Comodo.ray_triangle_intersect"><code>Comodo.ray_triangle_intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ray_triangle_intersect(F::Vector{TriangleFace{Int64}},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))
ray_triangle_intersect(f::TriangleFace{Int64},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))</code></pre><p><strong>Description</strong></p><p>This function can compute triangle-ray or triangle-line intersections through  the use of the &quot;Möller-Trumbore triangle-ray intersection algorithm&quot;. The  required inputs are as follows: </p><p><code>F</code> an single face or a vector of faces, e.g. <code>Vector{TriangleFace{Int64}}</code> <code>V</code> The triangle vertices as a vector of points, i.e. <code>Vector{GeometryBasics.Point{3, Float64}}</code> <code>ray_vector</code> The ray vector which can be <code>Vector{GeometryBasics.Point{3, Float64}}</code> or <code>Vec3{Float64}</code></p><p>The following optional input parameters can be provided:  <code>rayType = :ray</code> (default) or <code>:line</code>. This defines wether the vector is treated as a ray (extends indefinately) or as a line (finite length) <code>triSide = 1</code> (default) or <code>0</code> or <code>-1</code>.  When <code>triSide=1</code> only the inward intersections are considered, e.g. when the ray or line enters the shape (ray/line is pointing against face normal) When <code>triSide=-1</code> only the outward intersections are considered, e.g. when the ray or line exits the shape (ray/line is pointing allong face normal) When <code>triSide=0</code> both inward and outward intersections are considered. <code>tolEps = eps(Float64)</code> (default) </p><p><strong>References</strong></p><p><a href="https://doi.org/10.1080/10867651.1997.10487468">Möller, Tomas; Trumbore, Ben (1997). &quot;Fast, Minimum Storage Ray-Triangle Intersection&quot;. Journal of Graphics Tools. 2: 21-28. doi: 10.1080/10867651.1997.10487468.</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L2493-L2516">source</a></section></article><h2 id="mesh_curvature_polynomial"><a class="docs-heading-anchor" href="#mesh_curvature_polynomial"><code>mesh_curvature_polynomial</code></a><a id="mesh_curvature_polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#mesh_curvature_polynomial" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.mesh_curvature_polynomial" href="#Comodo.mesh_curvature_polynomial"><code>Comodo.mesh_curvature_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh_curvature_polynomial(F::Vector{TriangleFace{Int64}},V::Vector{Point3{Float64}})
mesh_curvature_polynomial(M::GeometryBasics.Mesh)</code></pre><p><strong>Description</strong></p><p>This function computes the mesh curvature at each vertex for the input mesh  defined by the face <code>F</code> and the vertices <code>V</code>. A local polynomial is fitted to  each point&#39;s &quot;Laplacian umbrella&quot; (point neighbourhood), and the curvature of  this fitted form is derived. Instead of the mesh faces and vertices one may  instead specify the <code>GeometryBasics.Mesh</code> <code>M</code> as the input. </p><p>The reference below provides more detail on the algorithm. In addition, this  implementation was created with the help of <a href="https://github.com/alecjacobson/geometry-processing-curvature/blob/master/README.md">this helpful document</a>,  which features a nice overview of the theory/steps involved in this algorithm. </p><p><strong>References</strong></p><p><a href="https://doi.org/10.1016/j.cagd.2004.09.004">F. Cazals and M. Pouget, &quot;Estimating differential quantities using polynomial fitting of osculating jets&quot;, Computer Aided Geometric Design, vol. 22, no. 2, pp. 121-146, Feb. 2005, doi: 10.1016/j.cagd.2004.09.004</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L2567-L2584">source</a></section></article><h2 id="smoothmesh_hc"><a class="docs-heading-anchor" href="#smoothmesh_hc"><code>smoothmesh_hc</code></a><a id="smoothmesh_hc-1"></a><a class="docs-heading-anchor-permalink" href="#smoothmesh_hc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.smoothmesh_hc" href="#Comodo.smoothmesh_hc"><code>Comodo.smoothmesh_hc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothmesh_hc(F,V, con_V2V=nothing; n=1, α=0.1, β=0.5, tolDist=nothing)</code></pre><p><strong>Description</strong></p><p>This function implements HC (Humphrey&#39;s Classes) smoothing. This method uses Laplacian like smoothing but aims to compensate for shrinkage/swelling by also  &quot;pushing back&quot; towards the original coordinates. </p><p><strong>Reference</strong></p><p><a href="https://doi.org/10.1111/1467-8659.00334">Vollmer et al. Improved Laplacian Smoothing of Noisy Surface Meshes, 1999. doi: 10.1111/1467-8659.00334</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L1780-L1791">source</a></section></article><h2 id="smoothmesh_laplacian"><a class="docs-heading-anchor" href="#smoothmesh_laplacian"><code>smoothmesh_laplacian</code></a><a id="smoothmesh_laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#smoothmesh_laplacian" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.smoothmesh_laplacian" href="#Comodo.smoothmesh_laplacian"><code>Comodo.smoothmesh_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothmesh_laplacian(F,V,con_V2V=nothing; n=1, λ=0.5)</code></pre><p><strong>Description</strong></p><p>This function implements weighted Laplacian mesh smoothing. At each  iteration, this method replaces each point by an updated coordinate based on the  mean coordinates of that point&#39;s Laplacian umbrella. The update features a lerp like weighting between the previous iterations coordinates and the mean  coordinates. The code features <code>Vs[q] = (1.0-λ).*Vs[q] .+ λ*mean(V[con_V2V[q]])</code> As can be seen, the weighting is controlled by the input parameter <code>λ</code> which is in the range (0,1). If <code>λ=0</code> then no smoothing occurs. If <code>λ=1</code> then pure  Laplacian mean based smoothing occurs. For intermediate values a linear blending between the two occurs.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L1739-L1754">source</a></section></article><h2 id="platonicsolid"><a class="docs-heading-anchor" href="#platonicsolid"><code>platonicsolid</code></a><a id="platonicsolid-1"></a><a class="docs-heading-anchor-permalink" href="#platonicsolid" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.platonicsolid" href="#Comodo.platonicsolid"><code>Comodo.platonicsolid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">platonicsolid(n,r=1.0)</code></pre><p><strong>Description</strong></p><p>Creates a GeometryBasics mesh description for a platonic solid of choice. The  input <code>n</code> defines the choice.</p><ol><li>tetrahedron</li><li>cube</li><li>octahedron</li><li>icosahedron</li><li>dodecahedron</li></ol><p>The final input parameter <code>r</code> defines the radius of the platonic solid (the  radius of the circumsphere to the vertices).</p><p><strong>Arguments</strong></p><p>n::Integer, defining platonic solid type r::Float64, defining circumsphere radius</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L1051-L1072">source</a></section></article><h2 id="sub2ind"><a class="docs-heading-anchor" href="#sub2ind"><code>sub2ind</code></a><a id="sub2ind-1"></a><a class="docs-heading-anchor-permalink" href="#sub2ind" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.sub2ind" href="#Comodo.sub2ind"><code>Comodo.sub2ind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sub2ind(siz,A)</code></pre><p><strong>Description</strong></p><p>Converts the subscript indices in <code>A</code>, for a matrix/array with size <code>siz</code>, to  the equivalent linear indices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L762-L769">source</a></section></article><h2 id="ind2sub"><a class="docs-heading-anchor" href="#ind2sub"><code>ind2sub</code></a><a id="ind2sub-1"></a><a class="docs-heading-anchor-permalink" href="#ind2sub" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.ind2sub" href="#Comodo.ind2sub"><code>Comodo.ind2sub</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ind2sub(siz,ind)</code></pre><p><strong>Description</strong></p><p>Converts the linear indices in <code>ind</code>, for a matrix/array with size <code>siz</code>, to the  equivalent subscript indices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/ebfa64539b7b85d37563ab973b9eab556378760b/src/functions.jl#L721-L727">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 3 April 2024 11:08">Wednesday 3 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
