<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · A Julia package for computational (bio)mechanics and computational design</title><meta name="title" content="Functions · A Julia package for computational (bio)mechanics and computational design"/><meta property="og:title" content="Functions · A Julia package for computational (bio)mechanics and computational design"/><meta property="twitter:title" content="Functions · A Julia package for computational (bio)mechanics and computational design"/><meta name="description" content="Documentation for A Julia package for computational (bio)mechanics and computational design."/><meta property="og:description" content="Documentation for A Julia package for computational (bio)mechanics and computational design."/><meta property="twitter:description" content="Documentation for A Julia package for computational (bio)mechanics and computational design."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>A Julia package for computational (bio)mechanics and computational design</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#comododir"><span><code>comododir</code></span></a></li><li><a class="tocitem" href="#slidercontrol"><span><code>slidercontrol</code></span></a></li><li><a class="tocitem" href="#slider2anim"><span><code>slider2anim</code></span></a></li><li><a class="tocitem" href="#elements2indices"><span><code>elements2indices</code></span></a></li><li><a class="tocitem" href="#gridpoints"><span><code>gridpoints</code></span></a></li><li><a class="tocitem" href="#gridpoints_equilateral"><span><code>gridpoints_equilateral</code></span></a></li><li><a class="tocitem" href="#interp_biharmonic_spline"><span><code>interp_biharmonic_spline</code></span></a></li><li><a class="tocitem" href="#interp_biharmonic"><span><code>interp_biharmonic</code></span></a></li><li><a class="tocitem" href="#nbezier"><span><code>nbezier</code></span></a></li><li><a class="tocitem" href="#lerp"><span><code>lerp</code></span></a></li><li><a class="tocitem" href="#dist"><span><code>dist</code></span></a></li><li><a class="tocitem" href="#mindist"><span><code>mindist</code></span></a></li><li><a class="tocitem" href="#unique_dict_index"><span><code>unique_dict_index</code></span></a></li><li><a class="tocitem" href="#unique_dict_index_inverse"><span><code>unique_dict_index_inverse</code></span></a></li><li><a class="tocitem" href="#unique_dict_index_count"><span><code>unique_dict_index_count</code></span></a></li><li><a class="tocitem" href="#unique_dict_index_inverse_count"><span><code>unique_dict_index_inverse_count</code></span></a></li><li><a class="tocitem" href="#unique_dict_count"><span><code>unique_dict_count</code></span></a></li><li><a class="tocitem" href="#unique_dict_inverse"><span><code>unique_dict_inverse</code></span></a></li><li><a class="tocitem" href="#unique_dict"><span><code>unique_dict</code></span></a></li><li><a class="tocitem" href="#gunique"><span><code>gunique</code></span></a></li><li><a class="tocitem" href="#unique_simplices"><span><code>unique_simplices</code></span></a></li><li><a class="tocitem" href="#ind2sub"><span><code>ind2sub</code></span></a></li><li><a class="tocitem" href="#sub2ind"><span><code>sub2ind</code></span></a></li><li><a class="tocitem" href="#meshedges"><span><code>meshedges</code></span></a></li><li><a class="tocitem" href="#icosahedron"><span><code>icosahedron</code></span></a></li><li><a class="tocitem" href="#octahedron"><span><code>octahedron</code></span></a></li><li><a class="tocitem" href="#dodecahedron"><span><code>dodecahedron</code></span></a></li><li><a class="tocitem" href="#cube"><span><code>cube</code></span></a></li><li><a class="tocitem" href="#tetrahedron"><span><code>tetrahedron</code></span></a></li><li><a class="tocitem" href="#platonicsolid"><span><code>platonicsolid</code></span></a></li><li><a class="tocitem" href="#tofaces"><span><code>tofaces</code></span></a></li><li><a class="tocitem" href="#topoints"><span><code>topoints</code></span></a></li><li><a class="tocitem" href="#togeometrybasics_mesh"><span><code>togeometrybasics_mesh</code></span></a></li><li><a class="tocitem" href="#edgecrossproduct"><span><code>edgecrossproduct</code></span></a></li><li><a class="tocitem" href="#facenormal"><span><code>facenormal</code></span></a></li><li><a class="tocitem" href="#facearea"><span><code>facearea</code></span></a></li><li><a class="tocitem" href="#vertexnormal"><span><code>vertexnormal</code></span></a></li><li><a class="tocitem" href="#edgelengths"><span><code>edgelengths</code></span></a></li><li><a class="tocitem" href="#subtri"><span><code>subtri</code></span></a></li><li><a class="tocitem" href="#subquad"><span><code>subquad</code></span></a></li><li><a class="tocitem" href="#geosphere"><span><code>geosphere</code></span></a></li><li><a class="tocitem" href="#hexbox"><span><code>hexbox</code></span></a></li><li><a class="tocitem" href="#con_face_edge"><span><code>con_face_edge</code></span></a></li><li><a class="tocitem" href="#con_edge_face"><span><code>con_edge_face</code></span></a></li><li><a class="tocitem" href="#con_face_face"><span><code>con_face_face</code></span></a></li><li><a class="tocitem" href="#con_face_face_v"><span><code>con_face_face_v</code></span></a></li><li><a class="tocitem" href="#con_vertex_simplex"><span><code>con_vertex_simplex</code></span></a></li><li><a class="tocitem" href="#con_vertex_face"><span><code>con_vertex_face</code></span></a></li><li><a class="tocitem" href="#con_vertex_edge"><span><code>con_vertex_edge</code></span></a></li><li><a class="tocitem" href="#con_edge_edge"><span><code>con_edge_edge</code></span></a></li><li><a class="tocitem" href="#con_vertex_vertex_f"><span><code>con_vertex_vertex_f</code></span></a></li><li><a class="tocitem" href="#con_vertex_vertex"><span><code>con_vertex_vertex</code></span></a></li><li><a class="tocitem" href="#meshconnectivity"><span><code>meshconnectivity</code></span></a></li><li><a class="tocitem" href="#mergevertices"><span><code>mergevertices</code></span></a></li><li><a class="tocitem" href="#smoothmesh_laplacian"><span><code>smoothmesh_laplacian</code></span></a></li><li><a class="tocitem" href="#smoothmesh_hc"><span><code>smoothmesh_hc</code></span></a></li><li><a class="tocitem" href="#quadplate"><span><code>quadplate</code></span></a></li><li><a class="tocitem" href="#quadsphere"><span><code>quadsphere</code></span></a></li><li><a class="tocitem" href="#loflinear"><span><code>loflinear</code></span></a></li><li><a class="tocitem" href="#pointspacingmean"><span><code>pointspacingmean</code></span></a></li><li><a class="tocitem" href="#ray_triangle_intersect"><span><code>ray_triangle_intersect</code></span></a></li><li><a class="tocitem" href="#mesh_curvature_polynomial"><span><code>mesh_curvature_polynomial</code></span></a></li><li><a class="tocitem" href="#separate_vertices"><span><code>separate_vertices</code></span></a></li><li><a class="tocitem" href="#evenly_sample"><span><code>evenly_sample</code></span></a></li><li><a class="tocitem" href="#invert_faces"><span><code>invert_faces</code></span></a></li><li><a class="tocitem" href="#kabsch_rot"><span><code>kabsch_rot</code></span></a></li><li><a class="tocitem" href="#sweeploft"><span><code>sweeploft</code></span></a></li><li><a class="tocitem" href="#revolvecurve"><span><code>revolvecurve</code></span></a></li><li><a class="tocitem" href="#batman"><span><code>batman</code></span></a></li><li><a class="tocitem" href="#tridisc"><span><code>tridisc</code></span></a></li><li><a class="tocitem" href="#regiontrimesh"><span><code>regiontrimesh</code></span></a></li><li><a class="tocitem" href="#scalesimplex"><span><code>scalesimplex</code></span></a></li><li><a class="tocitem" href="#subcurve"><span><code>subcurve</code></span></a></li><li><a class="tocitem" href="#dualclad"><span><code>dualclad</code></span></a></li><li><a class="tocitem" href="#tet2hex"><span><code>tet2hex</code></span></a></li><li><a class="tocitem" href="#element2faces"><span><code>element2faces</code></span></a></li><li><a class="tocitem" href="#subhex"><span><code>subhex</code></span></a></li><li><a class="tocitem" href="#rhombicdodecahedron"><span><code>rhombicdodecahedron</code></span></a></li><li><a class="tocitem" href="#tri2quad"><span><code>tri2quad</code></span></a></li><li><a class="tocitem" href="#tetgenmesh"><span><code>tetgenmesh</code></span></a></li><li><a class="tocitem" href="#surfacevolume"><span><code>surfacevolume</code></span></a></li><li><a class="tocitem" href="#tetvolume"><span><code>tetvolume</code></span></a></li><li><a class="tocitem" href="#extrudefaces"><span><code>extrudefaces</code></span></a></li><li><a class="tocitem" href="#filletcurve"><span><code>filletcurve</code></span></a></li><li><a class="tocitem" href="#squircle"><span><code>squircle</code></span></a></li><li><a class="tocitem" href="#circlerange"><span><code>circlerange</code></span></a></li><li><a class="tocitem" href="#edgefaceangles"><span><code>edgefaceangles</code></span></a></li><li><a class="tocitem" href="#faceanglesegment"><span><code>faceanglesegment</code></span></a></li><li><a class="tocitem" href="#eulerchar"><span><code>eulerchar</code></span></a></li><li><a class="tocitem" href="#rhombicdodecahedronfoam"><span><code>rhombicdodecahedronfoam</code></span></a></li><li><a class="tocitem" href="#truncatedoctahedron"><span><code>truncatedoctahedron</code></span></a></li><li><a class="tocitem" href="#kelvinfoam"><span><code>kelvinfoam</code></span></a></li><li><a class="tocitem" href="#minp"><span><code>minp</code></span></a></li><li><a class="tocitem" href="#maxp"><span><code>maxp</code></span></a></li><li><a class="tocitem" href="#ntrapezohedron"><span><code>ntrapezohedron</code></span></a></li><li><a class="tocitem" href="#spacing2numvertices"><span><code>spacing2numvertices</code></span></a></li><li><a class="tocitem" href="#joingeom"><span><code>joingeom</code></span></a></li><li><a class="tocitem" href="#quadbox"><span><code>quadbox</code></span></a></li><li><a class="tocitem" href="#tribox"><span><code>tribox</code></span></a></li><li><a class="tocitem" href="#tetbox"><span><code>tetbox</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/COMODO-research/Comodo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/COMODO-research/Comodo.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="comododir"><a class="docs-heading-anchor" href="#comododir"><code>comododir</code></a><a id="comododir-1"></a><a class="docs-heading-anchor-permalink" href="#comododir" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.comododir" href="#Comodo.comododir"><code>Comodo.comododir</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comododir()</code></pre><p><strong>Description</strong></p><p>This function simply returns the string for the Comodo path. This is helpful for instance to load items, such as meshes, from the <code>assets</code>` folder. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L53-L59">source</a></section></article><h2 id="slidercontrol"><a class="docs-heading-anchor" href="#slidercontrol"><code>slidercontrol</code></a><a id="slidercontrol-1"></a><a class="docs-heading-anchor-permalink" href="#slidercontrol" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.slidercontrol" href="#Comodo.slidercontrol"><code>Comodo.slidercontrol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slidercontrol(hSlider,ax)</code></pre><p>Adds arrow key control to sliders</p><p><strong>Description</strong></p><p>This function adds arrow key control to Makie sliders. The inputs are the  slider handle <code>hSlider</code> as well as the axis <code>ax</code>. If this function is called the slider can be advanced a step by pressing the right arrow, and returned one step  by pressing the left arrow. When one presses and holds the right or left arrow  key, the slider will continue to move (as fast as graphics updating is possible on your system) up to the end or start slider position respectively. Users may  also use the up or down arrow keys. These function the same as the right and  left arrow keys, however, rather than stopping at the slider extrema, the  sliders position will &quot;wrap&quot; back to the start when advancing beyond the end  position, and vice versa. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L65-L82">source</a></section></article><h2 id="slider2anim"><a class="docs-heading-anchor" href="#slider2anim"><code>slider2anim</code></a><a id="slider2anim-1"></a><a class="docs-heading-anchor-permalink" href="#slider2anim" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.slider2anim" href="#Comodo.slider2anim"><code>Comodo.slider2anim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slider2anim(fig::Figure,hSlider::Slider,fileName::String; backforth=true, duration=2)</code></pre><p>Exports movies from slider based visualisations.</p><p><strong>Description</strong></p><p>Converts the effect of the slider defined by the slider handle <code>hSlider</code> for the  figure <code>fig</code> to an animation/movie file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L116-L124">source</a></section></article><h2 id="elements2indices"><a class="docs-heading-anchor" href="#elements2indices"><code>elements2indices</code></a><a id="elements2indices-1"></a><a class="docs-heading-anchor-permalink" href="#elements2indices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.elements2indices" href="#Comodo.elements2indices"><code>Comodo.elements2indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elements2indices(F)</code></pre><p>Returns the indices contained in <code>F</code></p><p><strong>Description</strong></p><p>This function obtains the unique set of indices for the vertices (nodes)  used by the the simplices defined by <code>F</code>. The vector <code>F</code> may contain any type of  simplices. For instance the elements in <code>F</code> may be of the type  <code>GeometryBasics.TriangleFace</code> or <code>GeometryBasics.QuadFace</code> (or any other) for  surface mesh data. However, volumetric elements of any type are permitted. In essence this function simply returns <code>unique(reduce(vcat,F))</code>. Hence any suitable vector containing vectors of numbers permitted by  <code>reduce(vcat,F)</code> is supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L136-L151">source</a></section></article><h2 id="gridpoints"><a class="docs-heading-anchor" href="#gridpoints"><code>gridpoints</code></a><a id="gridpoints-1"></a><a class="docs-heading-anchor-permalink" href="#gridpoints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.gridpoints" href="#Comodo.gridpoints"><code>Comodo.gridpoints</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gridpoints(x::Vector{T}, y=x, z=x) where T&lt;:Real</code></pre><p>Returns 3D grids of points</p><p><strong>Description</strong></p><p>The <code>gridpoints</code> function returns a vector of 3D points which span a grid in 3D  space. Points are defined as per the input ranges or range vectors. The output  point vector contains elements of the type <code>Point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L156-L166">source</a></section></article><h2 id="gridpoints_equilateral"><a class="docs-heading-anchor" href="#gridpoints_equilateral"><code>gridpoints_equilateral</code></a><a id="gridpoints_equilateral-1"></a><a class="docs-heading-anchor-permalink" href="#gridpoints_equilateral" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.gridpoints_equilateral" href="#Comodo.gridpoints_equilateral"><code>Comodo.gridpoints_equilateral</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gridpoints_equilateral(xSpan,ySpan,pointSpacing::T; return_faces = false, rectangular=false) where T &lt;: Real</code></pre><p>Returns a &quot;grid&quot; of 3D points that are located on the corners of an equilateral triangle tesselation.</p><p><strong>Description</strong></p><p>This function returns 3D point data in the form of a <code>Vector{Point{3,Float64}}</code>.  The point distribution is for an equilateral triangle tesselation. The input  consists of the span in the x-, and y-direction, i.e. <code>xSpan</code> and <code>ySpan</code>  respectively, as well as the desired <code>pointSpacing</code>. The &quot;spans&quot; should be  vectors or tuples defining the minimum and maximum coordinates for the grid. The true point spacing in the x-direction is computed such that a nearest whole  number of steps can cover the required distance. Next this spacing is used to  create the equilateral triangle point grid. Although the <code>xSpan</code> is closely  adhered to through this method, the <code>ySpan</code> is not fully covered. In the  y-direction the grid does start at the minimum level, but may stop short of  reaching the maximum y as it may not be reachable in a whole number of steps  from the minimum. Optional arguments include <code>return_faces</code> (default is  <code>false</code>), which will cause the function to return triangular faces <code>F</code> as well  as the vertices <code>V</code>. Secondly the option <code>rectangular</code> will force the grid to  conform to a rectangular domain. This means the &quot;jagged&quot; sides are forced to be  flat such that all x-coordinates on the left are at the minimum in <code>xSpan</code> and all on the right are at the maximum in <code>xSpan</code>, however, this does result in a  non-uniform spacing at these edges.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L183-L208">source</a></section></article><h2 id="interp_biharmonic_spline"><a class="docs-heading-anchor" href="#interp_biharmonic_spline"><code>interp_biharmonic_spline</code></a><a id="interp_biharmonic_spline-1"></a><a class="docs-heading-anchor-permalink" href="#interp_biharmonic_spline" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.interp_biharmonic_spline" href="#Comodo.interp_biharmonic_spline"><code>Comodo.interp_biharmonic_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp_biharmonic_spline(x::Union{Vector{T}, AbstractRange{T}},y::Union{Vector{T}, AbstractRange{T}},xi::Union{Vector{T}, AbstractRange{T}}; extrapolate_method=:linear,pad_data=:linear) where T&lt;:Real</code></pre><p>Interpolates 1D (curve) data using biharmonic spline interpolation</p><p><strong>Description</strong></p><p>This function uses biharmonic spline interpolation [1], which features radial basis  functions. The input is assumed to represent ordered data, i.e. consequtive  unique points on a curve. The curve x-, and y-coordinates are provided through  the input parameters <code>x</code> and <code>y</code> respectively. The third input <code>xi</code> defines the  sites at which to interpolate. Each of in the input parameters can be either a  vector or a range. </p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1029/GL014i002p00139">David T. Sandwell, <em>Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data</em>, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L282-L298">source</a></section></article><h2 id="interp_biharmonic"><a class="docs-heading-anchor" href="#interp_biharmonic"><code>interp_biharmonic</code></a><a id="interp_biharmonic-1"></a><a class="docs-heading-anchor-permalink" href="#interp_biharmonic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.interp_biharmonic" href="#Comodo.interp_biharmonic"><code>Comodo.interp_biharmonic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp_biharmonic(x,y,xi)</code></pre><p>Interpolates n-dimensional data using biharmonic spline interpolation</p><p><strong>Description</strong></p><p>This function uses biharmonic interpolation [1]. The input <code>x</code> should define a  vector consisting of m points which are n-dimensional, and the input <code>y</code> should be a vector consisting of m scalar data values. </p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1029/GL014i002p00139">David T. Sandwell, <em>Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data</em>, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L389-L402">source</a></section></article><h2 id="nbezier"><a class="docs-heading-anchor" href="#nbezier"><code>nbezier</code></a><a id="nbezier-1"></a><a class="docs-heading-anchor-permalink" href="#nbezier" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.nbezier" href="#Comodo.nbezier"><code>Comodo.nbezier</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nbezier(P,n)</code></pre><p>Returns a Bezier spline for the control points P whose order matches the numbe  of control points provided. </p><p><strong>Description</strong></p><p>This function returns <code>n</code> points for an m-th order Bézier spline, based on the  m control points contained in the input vector <code>P</code>. This function supports point vectors with elements of the type <code>AbstractPoint{3}</code> (e.g. <code>Point{3, Float64}</code>) or <code>Vector{Float64}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L420-L432">source</a></section></article><h2 id="lerp"><a class="docs-heading-anchor" href="#lerp"><code>lerp</code></a><a id="lerp-1"></a><a class="docs-heading-anchor-permalink" href="#lerp" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.lerp" href="#Comodo.lerp"><code>Comodo.lerp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lerp(x::Union{T,Vector{T}, AbstractRange{T}},y,xi::Union{T,Vector{T}, AbstractRange{T}}) where T &lt;: Real</code></pre><p>Linear interpolation</p><p><strong>Description</strong></p><p>This linearly interpolates (lerps) the input data specified by the sites <code>x</code> and  data <code>y</code> at the specified sites <code>xi</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L455-L464">source</a></section></article><h2 id="dist"><a class="docs-heading-anchor" href="#dist"><code>dist</code></a><a id="dist-1"></a><a class="docs-heading-anchor-permalink" href="#dist" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.dist" href="#Comodo.dist"><code>Comodo.dist</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dist(V1,V2)</code></pre><p>Computes n-dimensional Euclidean distances</p><p><strong>Description</strong></p><p>Function compute an nxm distance matrix for the n inputs points in <code>V1</code>, and the m input points in <code>V2</code>. The input points may be multidimensional, in fact they can be any type supported by the <code>euclidean</code> function of <code>Distances.jl</code>.  See also: https://github.com/JuliaStats/Distances.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L500-L511">source</a></section></article><h2 id="mindist"><a class="docs-heading-anchor" href="#mindist"><code>mindist</code></a><a id="mindist-1"></a><a class="docs-heading-anchor-permalink" href="#mindist" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.mindist" href="#Comodo.mindist"><code>Comodo.mindist</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mindist(V1,V2; getIndex=false, skipSelf = false )</code></pre><p>Returns nearest point distances </p><p><strong>Description</strong></p><p>Returns the closest point distance for the input points <code>V1</code> with respect to the  input points <code>V2</code>. If the optional parameter <code>getIndex</code> is set to <code>true</code> (<code>false</code>  by default) then this function also returns the indices of the nearest points  in <code>V2</code> for each point in <code>V1</code>. For self-distance evaluation, i.e. if the same  point set is provided twice, then the optional parameter <code>skipSelf</code> can be set  t0 <code>true</code> (default is <code>false</code>) if &quot;self distances&quot; (e.g. the nth point to the  nth point) are to be avoided.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L538-L552">source</a></section></article><h2 id="unique_dict_index"><a class="docs-heading-anchor" href="#unique_dict_index"><code>unique_dict_index</code></a><a id="unique_dict_index-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict_index" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict_index" href="#Comodo.unique_dict_index"><code>Comodo.unique_dict_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict_index(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T &lt;: Any</code></pre><p>Returns unique values and indices</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the indices for them.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L581-L592">source</a></section></article><h2 id="unique_dict_index_inverse"><a class="docs-heading-anchor" href="#unique_dict_index_inverse"><code>unique_dict_index_inverse</code></a><a id="unique_dict_index_inverse-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict_index_inverse" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict_index_inverse" href="#Comodo.unique_dict_index_inverse"><code>Comodo.unique_dict_index_inverse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict_index_inverse(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T &lt;: Any</code></pre><p>Returns unique values, indices, and inverse indices</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the indices for them and the  reverse indices to retrieve the original from the unique entries.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L614-L626">source</a></section></article><h2 id="unique_dict_index_count"><a class="docs-heading-anchor" href="#unique_dict_index_count"><code>unique_dict_index_count</code></a><a id="unique_dict_index_count-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict_index_count" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict_index_count" href="#Comodo.unique_dict_index_count"><code>Comodo.unique_dict_index_count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict_index_count(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T &lt;: Any</code></pre><p>Returns unique values, indices, and counts</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the indices for them and the counts  in terms of how often they occured.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L654-L666">source</a></section></article><h2 id="unique_dict_index_inverse_count"><a class="docs-heading-anchor" href="#unique_dict_index_inverse_count"><code>unique_dict_index_inverse_count</code></a><a id="unique_dict_index_inverse_count-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict_index_inverse_count" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict_index_inverse_count" href="#Comodo.unique_dict_index_inverse_count"><code>Comodo.unique_dict_index_inverse_count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict_index_inverse_count(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T &lt;: Any</code></pre><p>Returns unique values, indices, inverse indices, and counts</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the indices for them and the reverse  indices to retrieve the original from the unique entries, and also the counts in  terms of how often they occured.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L696-L709">source</a></section></article><h2 id="unique_dict_count"><a class="docs-heading-anchor" href="#unique_dict_count"><code>unique_dict_count</code></a><a id="unique_dict_count-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict_count" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict_count" href="#Comodo.unique_dict_count"><code>Comodo.unique_dict_count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict_count(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T &lt;: Any</code></pre><p>Returns unique values and counts</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the counts in terms of how often  they occured.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L741-L753">source</a></section></article><h2 id="unique_dict_inverse"><a class="docs-heading-anchor" href="#unique_dict_inverse"><code>unique_dict_inverse</code></a><a id="unique_dict_inverse-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict_inverse" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict_inverse" href="#Comodo.unique_dict_inverse"><code>Comodo.unique_dict_inverse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict_inverse(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T &lt;: Any</code></pre><p>Returns unique values and inverse indices</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the reverse indices to retrieve the  original from the unique entries.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L779-L791">source</a></section></article><h2 id="unique_dict"><a class="docs-heading-anchor" href="#unique_dict"><code>unique_dict</code></a><a id="unique_dict-1"></a><a class="docs-heading-anchor-permalink" href="#unique_dict" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_dict" href="#Comodo.unique_dict"><code>Comodo.unique_dict</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_dict(X::AbstractVector{T}) where T &lt;: Real</code></pre><p>Returns unique values, indices, and inverse indices. Uses an OrderedDict.</p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code> as well as the indices for them and the reverse  indices to retrieve the original from the unique entries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L818-L827">source</a></section></article><h2 id="gunique"><a class="docs-heading-anchor" href="#gunique"><code>gunique</code></a><a id="gunique-1"></a><a class="docs-heading-anchor-permalink" href="#gunique" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.gunique" href="#Comodo.gunique"><code>Comodo.gunique</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gunique(X; return_unique=true, return_index=false, return_inverse=false, return_counts=false, sort_entries=false)</code></pre><p>Returns unique values and allows users to choose if they also want: sorting, indices, inverse indices, and counts. </p><p><strong>Description</strong></p><p>Returns the unique entries in <code>X</code>. Depending on the optional parameter choices the indices for the unique entries, the reverse indices to retrieve the original from the unique entries, as well as counts in terms of how often they occured,  can be returned.  The optional parameter <code>sort_entries</code> (default is <code>false</code>) can be set to <code>true</code> if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L878-L892">source</a></section></article><h2 id="unique_simplices"><a class="docs-heading-anchor" href="#unique_simplices"><code>unique_simplices</code></a><a id="unique_simplices-1"></a><a class="docs-heading-anchor-permalink" href="#unique_simplices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.unique_simplices" href="#Comodo.unique_simplices"><code>Comodo.unique_simplices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_simplices(F,V=nothing)</code></pre><p>Returns unique simplices (such as faces), independant of node order</p><p><strong>Description</strong></p><p>Returns the unique simplices in F as well as the indices of the unique simplices and the reverse indices to retrieve the original faces from the unique faces.  Entries in F are sorted such that the node order does not matter. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L924-L934">source</a></section></article><h2 id="ind2sub"><a class="docs-heading-anchor" href="#ind2sub"><code>ind2sub</code></a><a id="ind2sub-1"></a><a class="docs-heading-anchor-permalink" href="#ind2sub" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.ind2sub" href="#Comodo.ind2sub"><code>Comodo.ind2sub</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ind2sub(siz,ind)</code></pre><p>Converts linear indices to subscript indices. </p><p><strong>Description</strong></p><p>Converts the linear indices in <code>ind</code>, for a matrix/array with size <code>siz</code>, to the  equivalent subscript indices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L948-L957">source</a></section></article><h2 id="sub2ind"><a class="docs-heading-anchor" href="#sub2ind"><code>sub2ind</code></a><a id="sub2ind-1"></a><a class="docs-heading-anchor-permalink" href="#sub2ind" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.sub2ind" href="#Comodo.sub2ind"><code>Comodo.sub2ind</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sub2ind(siz,A)</code></pre><p>Converts subscript indices to linear indices. </p><p><strong>Description</strong></p><p>Converts the subscript indices in <code>A</code>, for a matrix/array with size <code>siz</code>, to  the equivalent linear indices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L993-L1002">source</a></section></article><h2 id="meshedges"><a class="docs-heading-anchor" href="#meshedges"><code>meshedges</code></a><a id="meshedges-1"></a><a class="docs-heading-anchor-permalink" href="#meshedges" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.meshedges" href="#Comodo.meshedges"><code>Comodo.meshedges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meshedges(F::Array{NgonFace{N,T},1}; unique_only=false) where N where T&lt;:Integer</code></pre><p>Returns a mesh&#39;s edges.</p><p><strong>Description</strong></p><p>This function returns the edges <code>E</code> for the input faces defined by <code>F</code>.  The input <code>F</code> can either represent a vector of faces or a  GeometryBasics.Mesh. The convention is such that for a face referring to the  nodes 1-2-3-4, the edges are 1-2, 2-3, 3-4, 4-1.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1046-L1057">source</a></section></article><h2 id="icosahedron"><a class="docs-heading-anchor" href="#icosahedron"><code>icosahedron</code></a><a id="icosahedron-1"></a><a class="docs-heading-anchor-permalink" href="#icosahedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.icosahedron" href="#Comodo.icosahedron"><code>Comodo.icosahedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">icosahedron(r=1.0)</code></pre><p>Creates an icosahedron mesh. </p><p><strong>Description</strong></p><p>Creates a GeometryBasics.Mesh for an icosahedron with radius <code>r</code>. The default  radius, when not supplied, is <code>1.0</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1075-L1084">source</a></section></article><h2 id="octahedron"><a class="docs-heading-anchor" href="#octahedron"><code>octahedron</code></a><a id="octahedron-1"></a><a class="docs-heading-anchor-permalink" href="#octahedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.octahedron" href="#Comodo.octahedron"><code>Comodo.octahedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">octahedron(r=1.0)</code></pre><p>Creates an octahedron mesh. </p><p><strong>Description</strong></p><p>Creates a GeometryBasics.Mesh for an octahedron with radius <code>r</code>. The default  radius, when not supplied, is <code>1.0</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1133-L1142">source</a></section></article><h2 id="dodecahedron"><a class="docs-heading-anchor" href="#dodecahedron"><code>dodecahedron</code></a><a id="dodecahedron-1"></a><a class="docs-heading-anchor-permalink" href="#dodecahedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.dodecahedron" href="#Comodo.dodecahedron"><code>Comodo.dodecahedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dodecahedron(r=1.0)</code></pre><p>Creates a dodecahedron mesh. </p><p><strong>Description</strong></p><p>Creates a GeometryBasics.Mesh for an dodecahedron with radius <code>r</code>. The default  radius, when not supplied, is <code>1.0</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1169-L1178">source</a></section></article><h2 id="cube"><a class="docs-heading-anchor" href="#cube"><code>cube</code></a><a id="cube-1"></a><a class="docs-heading-anchor-permalink" href="#cube" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.cube" href="#Comodo.cube"><code>Comodo.cube</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cube(r=1.0)</code></pre><p>Creates a cube mesh. </p><p><strong>Description</strong></p><p>Creates a GeometryBasics.Mesh for an cube with radius <code>r</code>. The default  radius, when not supplied, is <code>1.0</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1230-L1239">source</a></section></article><h2 id="tetrahedron"><a class="docs-heading-anchor" href="#tetrahedron"><code>tetrahedron</code></a><a id="tetrahedron-1"></a><a class="docs-heading-anchor-permalink" href="#tetrahedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tetrahedron" href="#Comodo.tetrahedron"><code>Comodo.tetrahedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tetrahedron(r=1.0)</code></pre><p>Creates a tetrahedron mesh. </p><p><strong>Description</strong></p><p>Creates a GeometryBasics.Mesh for an tetrahedron with radius <code>r</code>. The default  radius, when not supplied, is <code>1.0</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1267-L1276">source</a></section></article><h2 id="platonicsolid"><a class="docs-heading-anchor" href="#platonicsolid"><code>platonicsolid</code></a><a id="platonicsolid-1"></a><a class="docs-heading-anchor-permalink" href="#platonicsolid" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.platonicsolid" href="#Comodo.platonicsolid"><code>Comodo.platonicsolid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">platonicsolid(n,r=1.0)</code></pre><p>Returns a platonic solid mesh.</p><p><strong>Description</strong></p><p>Creates a GeometryBasics mesh description for a platonic solid of choice. The  input <code>n</code> defines the choice.</p><ol><li>tetrahedron</li><li>cube</li><li>octahedron</li><li>icosahedron</li><li>dodecahedron</li></ol><p>The final input parameter <code>r</code> defines the radius of the platonic solid (the  radius of the circumsphere to the vertices).  The default radius, when not  supplied, is <code>1.0</code>. </p><p><strong>Arguments</strong></p><p>n::Integer, defining platonic solid type r::Float64, defining circumsphere radius</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1300-L1324">source</a></section></article><h2 id="tofaces"><a class="docs-heading-anchor" href="#tofaces"><code>tofaces</code></a><a id="tofaces-1"></a><a class="docs-heading-anchor-permalink" href="#tofaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tofaces" href="#Comodo.tofaces"><code>Comodo.tofaces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tofaces(FM::Vector{Vector{TF}}) where TF&lt;:Integer
tofaces(FM::Matrix{TF})  where TF&lt;:Integer
tofaces(FM::Vector{NgonFace{m, OffsetInteger{-1, TF}}} ) where m where TF &lt;: Integer
tofaces(FM::Vector{NgonFace{m, TF}} ) where m where TF &lt;: Integer</code></pre><p>Converts input to GeometryBasics compliant faces with standard integer types. </p><p><strong>Description</strong></p><p>The <code>tofaces</code> function converts &quot;non-standard&quot; (for Comodo) face set  descriptions to &quot;standard&quot; ones. The following is considered such as standard:  <code>Vector{GeometryBasics.NgonFace{N,T}} where N where T&lt;:Integer</code>  The input faces <code>FM</code> are converted to this format. <code>FM</code> can be of the following  types: </p><ul><li><code>FM::Vector{Vector{TF}} where TF&lt;:Integer</code>, whereby each Vector entry is </li></ul><p>considered a face</p><ul><li><code>FM::Matrix{TF} where TF&lt;:Integer</code>, whereby each row is considered a face</li><li><code>Vector{NgonFace{m, OffsetInteger{-1, TF}}} where TF&lt;:Integer</code>, whereby the </li></ul><p>special integer type <code>OffsetInteger{-1, TF}</code> is converted to <code>Int</code>.   If the intput is already of the right type this function leaves the input  unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1340-L1362">source</a></section></article><h2 id="topoints"><a class="docs-heading-anchor" href="#topoints"><code>topoints</code></a><a id="topoints-1"></a><a class="docs-heading-anchor-permalink" href="#topoints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.topoints" href="#Comodo.topoints"><code>Comodo.topoints</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">topoints(VM::Matrix{T}) where T&lt;: Real
topoints(VM::Union{Array{Vec{N, T}, 1}, GeometryBasics.StructArray{TT,1} }) where TT &lt;: AbstractPoint{N,T} where T &lt;: Real where N   
topoints(VM::Vector{Vector{T}}) where T &lt;: Real  
topoints(VM::Vector{Point{ND,TV}}) where ND where TV &lt;: Real</code></pre><p>Converts input to GeometryBasics compliant simple points without meta content.</p><p><strong>Description</strong></p><p>The <code>topoints</code> function converts the &quot;non-standard&quot; (for Comodo) input points  defined by <code>VM</code> to the &quot;standard&quot; format: <code>VM::Vector{Point{ND,TV}} where ND where TV &lt;: Real</code>. For matrix input each row is considered a point. For vector input each vector  entry is considered a point.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1411-L1425">source</a></section></article><h2 id="togeometrybasics_mesh"><a class="docs-heading-anchor" href="#togeometrybasics_mesh"><code>togeometrybasics_mesh</code></a><a id="togeometrybasics_mesh-1"></a><a class="docs-heading-anchor-permalink" href="#togeometrybasics_mesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.togeometrybasics_mesh" href="#Comodo.togeometrybasics_mesh"><code>Comodo.togeometrybasics_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">togeometrybasics_mesh</code></pre><p>Converts the input to a GeometryBasics.Mesh</p><p><strong>Description</strong></p><p>This function converts the input faces <code>F</code> and vertices <code>V</code> to a  GeometryBasics.Mesh. The function <code>tofaces</code> and <code>topoints</code> are used prior to  conversion, to ensure standard faces and point types are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1448-L1458">source</a></section></article><h2 id="edgecrossproduct"><a class="docs-heading-anchor" href="#edgecrossproduct"><code>edgecrossproduct</code></a><a id="edgecrossproduct-1"></a><a class="docs-heading-anchor-permalink" href="#edgecrossproduct" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.edgecrossproduct" href="#Comodo.edgecrossproduct"><code>Comodo.edgecrossproduct</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edgecrossproduct(F,V::Vector{Point{ND,T}}) where ND where T&lt;:Real</code></pre><p>Returns the edge cross product, useful for nomal direction and area computations. </p><pre><code class="nohighlight hljs"># Description</code></pre><p>This function computes the so-called edge-cross-product for a input mesh that is either defined by the faces <code>F</code> and vertices <code>V</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1466-L1475">source</a></section></article><h2 id="facenormal"><a class="docs-heading-anchor" href="#facenormal"><code>facenormal</code></a><a id="facenormal-1"></a><a class="docs-heading-anchor-permalink" href="#facenormal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.facenormal" href="#Comodo.facenormal"><code>Comodo.facenormal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">facenormal(F,V)</code></pre><p>Returns the normal directions for each face.</p><p><strong>Description</strong></p><p>This function computes the per face normal directions for the input mesh defined  either by the faces <code>F</code> and vertices <code>V</code> or by the GeometryBasics mesh <code>M</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1508-L1517">source</a></section></article><h2 id="facearea"><a class="docs-heading-anchor" href="#facearea"><code>facearea</code></a><a id="facearea-1"></a><a class="docs-heading-anchor-permalink" href="#facearea" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.facearea" href="#Comodo.facearea"><code>Comodo.facearea</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">facearea(F,V)</code></pre><p>Returns the area for each face. </p><p><strong>Description</strong></p><p>This function computes the per face area for the input mesh defined either by  the faces <code>F</code> and vertices <code>V</code> or by the GeometryBasics mesh <code>M</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1533-L1542">source</a></section></article><h2 id="vertexnormal"><a class="docs-heading-anchor" href="#vertexnormal"><code>vertexnormal</code></a><a id="vertexnormal-1"></a><a class="docs-heading-anchor-permalink" href="#vertexnormal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.vertexnormal" href="#Comodo.vertexnormal"><code>Comodo.vertexnormal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertexnormal(F,V; weighting=:area)</code></pre><p>Returns the surface normal at each vertex.</p><p><strong>Description</strong></p><p>This function computes the per vertex surface normal directions for the input  mesh defined either by the faces <code>F</code> and vertices <code>V</code> or by the GeometryBasics mesh <code>M</code>. The optional parameter <code>weighting</code> sets how the face normal directions  are averaged onto the vertices. If <code>weighting=:none</code> a plain average for the  surrounding faces is used. If instead <code>weighting=:area</code> (default), then the average is weighted based on the face areas. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1552-L1565">source</a></section></article><h2 id="edgelengths"><a class="docs-heading-anchor" href="#edgelengths"><code>edgelengths</code></a><a id="edgelengths-1"></a><a class="docs-heading-anchor-permalink" href="#edgelengths" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.edgelengths" href="#Comodo.edgelengths"><code>Comodo.edgelengths</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edgelengths(E::LineFace,V)
edgelengths(F,V)
edgelengths(M::GeometryBasics.Mesh)</code></pre><p>Returns edge lengths.</p><p><strong>Description</strong></p><p>This function computes the lengths of the edges defined by edge vector <code>E</code> (e.g as obtained from <code>meshedges(F,V)</code>, where <code>F</code> is a face vector, and <code>V</code> is a  vector of vertices.  Alternatively the input mesh can be a GeometryBasics mesh <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1575-L1587">source</a></section></article><h2 id="subtri"><a class="docs-heading-anchor" href="#subtri"><code>subtri</code></a><a id="subtri-1"></a><a class="docs-heading-anchor-permalink" href="#subtri" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.subtri" href="#Comodo.subtri"><code>Comodo.subtri</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subtri(F,V,n; method = :linear)
subtri(F,V,n; method = :Loop)</code></pre><p>Refines triangulations through splitting.</p><p><strong>Description</strong></p><p>The <code>subtri</code> function refines triangulated meshes iteratively. For each iteration each original input triangle is split into 4 triangles to form the refined mesh  (one central one, and 3 at each corner). The following refinement methods are  implemented: </p><p><code>method=:linear</code> : This is the default method, and refines the triangles in a  simple linear manor through splitting. Each input edge simply obtains a new  mid-edge node. </p><p><code>method=:Loop</code> : This method features Loop-subdivision [1,2]. Rather than linearly  splitting edges and maintaining the original coordinates, as for the linear  method, this method computes the new points in a special weighted sense such  that the surface effectively approaches a &quot;quartic box spline&quot;. Hence this  method both refines and smoothes the geometry through spline approximation. </p><p><strong>References</strong></p><ol><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/thesis-10.pdf">Charles Loop, <em>Smooth Subdivision Surfaces Based on Triangles</em>, M.S. Mathematics Thesis, University of Utah. 1987.</a></li><li><a href="https://doi.org/10.1111/1467-8659.t01-2-00647">Jos Stam, Charles Loop, <em>Quad/Triangle Subdivision</em>, doi: 10.1111/1467-8659.t01-2-00647</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1601-L1627">source</a></section></article><h2 id="subquad"><a class="docs-heading-anchor" href="#subquad"><code>subquad</code></a><a id="subquad-1"></a><a class="docs-heading-anchor-permalink" href="#subquad" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.subquad" href="#Comodo.subquad"><code>Comodo.subquad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>subquad(F::Vector{NgonFace{4,TF}},V::Vector{Point{ND,TV}},n::Int; method=:linear) where TF&lt;:Integer where ND where TV &lt;: Real subquad(F::Vector{NgonFace{4,TF}},V::Vector{Point{ND,TV}},n::Int; method=:Catmull_Clark) where TF&lt;:Integer where ND where TV &lt;: Real</p><p>Refines quadrangulations through splitting.</p><p><strong>Description</strong></p><p>The <code>subquad</code> function refines quad meshes iteratively. For each iteration each original input quad is split into 4 smaller quads to form the refined mesh.  The following refinement methods are implemented: </p><p><code>method=:linear</code> : This is the default method, and refines the quads in a  simple linear manor through splitting. Each input edge simply obtains a new  mid-edge node, and each face obtains a new central node. </p><p><code>method=:Catmull_Clark</code> : This method features Catmull_Clark-subdivision [1].  Rather than linearly splitting edges and maintaining the original coordinates,  as for the linear method, this method computes the new points in a special  weighted sense such that the surface effectively approaches a bicubic B-spline  surface. Hence this method both refines and smoothes the geometry through  spline approximation. </p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1016/0010-4485(78)90110-0">E. Catmull and J. Clark, <em>Recursively generated B-spline surfaces on arbitrary topological meshes</em>, Computer-Aided Design, vol. 10, no. 6, pp. 350-355, Nov. 1978, doi: 10.1016/0010-4485(78)90110-0</a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1728-L1753">source</a></section></article><h2 id="geosphere"><a class="docs-heading-anchor" href="#geosphere"><code>geosphere</code></a><a id="geosphere-1"></a><a class="docs-heading-anchor-permalink" href="#geosphere" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.geosphere" href="#Comodo.geosphere"><code>Comodo.geosphere</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geosphere(n::Int,r::T; method=:linear) where T &lt;: Real</code></pre><p>Returns a geodesic sphere triangulation</p><p><strong>Description</strong></p><p>This function returns a geodesic sphere triangulation based on the number of refinement iterations <code>n</code> and the radius <code>r</code>. Geodesic spheres (aka Buckminster-Fuller  spheres) are triangulations of a sphere that have near uniform edge lenghts.  The algorithm starts with a regular icosahedron. Next this icosahedron is refined  <code>n</code> times, while nodes are pushed to a sphere surface with radius <code>r</code> at each iteration. Two methods are available, i.e. <code>:linear</code> (default) and <code>:Loop</code>  (see also <code>subtri</code>). The former features simply linear splitting while the latter features the Loop method which may produce a smoother result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1846-L1861">source</a></section></article><h2 id="hexbox"><a class="docs-heading-anchor" href="#hexbox"><code>hexbox</code></a><a id="hexbox-1"></a><a class="docs-heading-anchor-permalink" href="#hexbox" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.hexbox" href="#Comodo.hexbox"><code>Comodo.hexbox</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hexbox(boxDim,boxEl)</code></pre><p>Returns a hexahedral mesh of a box</p><p><strong>Description</strong></p><p>This function returns a hexahedral mesh for a 3D rectangular box domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L1976-L1984">source</a></section></article><h2 id="con_face_edge"><a class="docs-heading-anchor" href="#con_face_edge"><code>con_face_edge</code></a><a id="con_face_edge-1"></a><a class="docs-heading-anchor-permalink" href="#con_face_edge" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_face_edge" href="#Comodo.con_face_edge"><code>Comodo.con_face_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_face_edge(F,E_uni=nothing,indReverse=nothing)</code></pre><p>Returns the edges connected to each face.</p><p><strong>Description</strong></p><p>This function computes the face-edge connectivity. The input faces <code>F</code> (and  optionally also the unique edges <code>E_uni</code> and reverse indices <code>indReverse</code> to map to the non-unique edges, see also <code>gunique</code>) are used to create a list of edges  connected to each face. If <code>F</code> contains N faces then the output contains N such  lists. For triangles the output contains 3 edges per faces, for quads 4 per face and so on.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2040-L2053">source</a></section></article><h2 id="con_edge_face"><a class="docs-heading-anchor" href="#con_edge_face"><code>con_edge_face</code></a><a id="con_edge_face-1"></a><a class="docs-heading-anchor-permalink" href="#con_edge_face" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_edge_face" href="#Comodo.con_edge_face"><code>Comodo.con_edge_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>con<em>edge</em>face(F,E_uni=nothing,indReverse=nothing)</p><p>Returns the faces connected to each edge.</p><p><strong>Description</strong></p><p>This function computes the edge-face connectivity. The input faces <code>F</code> (and  optionally also the unique edges <code>E_uni</code> and reverse indices <code>indReverse</code> to map to the non-unique edges, see also <code>gunique</code>) are used to create a list of faces  connected to each edges. If <code>E_uni</code> contains N edges then the output contains  N such lists. For non-boundary edges each edge should connect to 2 faces.  Boundary edges connect to just 1 face.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2063-L2076">source</a></section></article><h2 id="con_face_face"><a class="docs-heading-anchor" href="#con_face_face"><code>con_face_face</code></a><a id="con_face_face-1"></a><a class="docs-heading-anchor-permalink" href="#con_face_face" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_face_face" href="#Comodo.con_face_face"><code>Comodo.con_face_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_face_face(F,E_uni=nothing,indReverse=nothing,con_E2F=nothing,con_F2E=nothing)</code></pre><p>Returns the edge-connected faces for each face.</p><p><strong>Description</strong></p><p>This function computes the face-face connectivity for each face. The input faces <code>F</code> are used to create a list of faces connected to each face by a shared edge. For non-boundary triangles for instance the output contains 3 edges per faces  (which may be less for boundary triangles), and similarly non-boundary quads  would each have 4 edge-connected faces. Additional optional inputs include: the  unique edges <code>E_uni</code>, the reverse indices <code>indReverse</code> to map to the non-unique  edges (see also <code>gunique</code>), as well as the edge-face <code>con_E2F</code> and face-edge  <code>con_F2E</code> connectivity. These are all needed for computing the face-face  connectivity and supplying them if already computed therefore save time.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2094-L2110">source</a></section></article><h2 id="con_face_face_v"><a class="docs-heading-anchor" href="#con_face_face_v"><code>con_face_face_v</code></a><a id="con_face_face_v-1"></a><a class="docs-heading-anchor-permalink" href="#con_face_face_v" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_face_face_v" href="#Comodo.con_face_face_v"><code>Comodo.con_face_face_v</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_face_face_v(F,V=nothing,con_V2F=nothing)</code></pre><p>Returns the vertex-connected faces for each face.</p><p><strong>Description</strong></p><p>This function computes the face-face connectivity for each face. The input faces <code>F</code> are used to create a list of faces connected to each face by a shared vertex. Additional optional inputs include: the vertices <code>V</code>, and the vertex-face  connectivity <code>con_V2F</code>. In terms of vertices only the number of vertices, i.e.  <code>length(V)</code> is neede, if <code>V</code> is not provided it is assumed that <code>length(V)</code>  corresponds to the largest index in <code>F</code>. The vertex-face connectivity if not supplied, will be computed by this function, hence computational time may be saved  if it was already computed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2138-L2153">source</a></section></article><h2 id="con_vertex_simplex"><a class="docs-heading-anchor" href="#con_vertex_simplex"><code>con_vertex_simplex</code></a><a id="con_vertex_simplex-1"></a><a class="docs-heading-anchor-permalink" href="#con_vertex_simplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_vertex_simplex" href="#Comodo.con_vertex_simplex"><code>Comodo.con_vertex_simplex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_vertex_simplex(F,V=nothing)</code></pre><p>Returns how vertices connect to simplices</p><p><strong>Description</strong></p><p>This function computes the vertex-simplex connectivity for each vertex. The input simplices <code>F</code> are used to create a list of simplices connected to each vertex. Additional optional inputs include: the vertices <code>V</code>. In terms of vertices only the number of vertices, i.e. <code>length(V)</code> is needed,  if <code>V</code> is not provided it is assumed that <code>length(V)</code> corresponds to the largest index in <code>F</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2173-L2186">source</a></section></article><h2 id="con_vertex_face"><a class="docs-heading-anchor" href="#con_vertex_face"><code>con_vertex_face</code></a><a id="con_vertex_face-1"></a><a class="docs-heading-anchor-permalink" href="#con_vertex_face" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_vertex_face" href="#Comodo.con_vertex_face"><code>Comodo.con_vertex_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_vertex_face(F,V=nothing)</code></pre><p>Returns how vertices connect to faces</p><p><strong>Description</strong></p><p>This function is an alias of <code>con_vertex_simplex</code>, and computes the vertex-face  connectivity for each vertex. The input faces <code>F</code> are used to create a list of  faces connected to each vertex. Additional optional inputs include: the vertices <code>V</code>. In terms of vertices only the number of vertices, i.e. <code>length(V)</code> is needed,  if <code>V</code> is not provided it is assumed that <code>length(V)</code> corresponds to the largest index in <code>F</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2202-L2214">source</a></section></article><h2 id="con_vertex_edge"><a class="docs-heading-anchor" href="#con_vertex_edge"><code>con_vertex_edge</code></a><a id="con_vertex_edge-1"></a><a class="docs-heading-anchor-permalink" href="#con_vertex_edge" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_vertex_edge" href="#Comodo.con_vertex_edge"><code>Comodo.con_vertex_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_vertex_edge(F,V=nothing)</code></pre><p>Returns how vertices connect to edges</p><p><strong>Description</strong></p><p>This function is an alias of <code>con_vertex_simplex</code>, and computes the vertex-edge  connectivity for each vertex. The input edges <code>E</code> are used to create a list of  edges connected to each vertex. Additional optional inputs include: the vertices <code>V</code>. In terms of vertices only the number of vertices, i.e. <code>length(V)</code> is needed,  if <code>V</code> is not provided it is assumed that <code>length(V)</code> corresponds to the largest index in <code>E</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2220-L2232">source</a></section></article><h2 id="con_edge_edge"><a class="docs-heading-anchor" href="#con_edge_edge"><code>con_edge_edge</code></a><a id="con_edge_edge-1"></a><a class="docs-heading-anchor-permalink" href="#con_edge_edge" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_edge_edge" href="#Comodo.con_edge_edge"><code>Comodo.con_edge_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_edge_edge(E_uni,con_V2E=nothing)</code></pre><p>Returns the vertex-connected edges for each edge.</p><p><strong>Description</strong></p><p>This function computes the edge-edge connectivity for each edge. The input edges <code>F</code> are used to create a list of edges connected to each edge by a shared vertex. Additional optional inputs include: <code>con_V2E</code> (the vertex-edge connectivity), which is instead computed when not provided.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2237-L2248">source</a></section></article><h2 id="con_vertex_vertex_f"><a class="docs-heading-anchor" href="#con_vertex_vertex_f"><code>con_vertex_vertex_f</code></a><a id="con_vertex_vertex_f-1"></a><a class="docs-heading-anchor-permalink" href="#con_vertex_vertex_f" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_vertex_vertex_f" href="#Comodo.con_vertex_vertex_f"><code>Comodo.con_vertex_vertex_f</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_vertex_vertex_f(F,V=nothing,con_V2F=nothing)</code></pre><p>Returns the face-connected vertices for each vertex.</p><p><strong>Description</strong></p><p>This function computes the vertex-vertex connectivity for each vertex using the  vertex connected faces. The input faces <code>F</code> are used to create a list of vertices connected to each vertex by a shared face. Additional optional inputs include:  the vertices <code>V</code> and <code>con_V2F</code> (the vertex-face connectivity). In terms of vertices only the number of vertices, i.e. <code>length(V)</code> is needed, if <code>V</code> is not provided  it is assumed that <code>length(V)</code> corresponds to the largest index in <code>F</code>. The  vertex-face connectivity <code>con_V2F</code> is needed, hence is computed when not provided.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2264-L2278">source</a></section></article><h2 id="con_vertex_vertex"><a class="docs-heading-anchor" href="#con_vertex_vertex"><code>con_vertex_vertex</code></a><a id="con_vertex_vertex-1"></a><a class="docs-heading-anchor-permalink" href="#con_vertex_vertex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.con_vertex_vertex" href="#Comodo.con_vertex_vertex"><code>Comodo.con_vertex_vertex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">con_vertex_vertex(E,V=nothing,con_V2E=nothing)</code></pre><p>Returns the edge-connected vertices for each vertex.</p><p><strong>Description</strong></p><p>This function computes the vertex-vertex connectivity for each vertex using the  vertex connected edges. The input edges <code>E</code> are used to create a list of vertices connected to each vertex by a shared edge. Additional optional inputs include:  the vertices <code>V</code> and <code>con_V2E</code> (the vertex-edge connectivity). In terms of vertices only the number of vertices, i.e. <code>length(V)</code> is needed, if <code>V</code> is not provided  it is assumed that <code>length(V)</code> corresponds to the largest index in <code>E</code>. The  vertex-edge connectivity <code>con_V2E</code> is needed, hence is computed when not provided.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2304-L2318">source</a></section></article><h2 id="meshconnectivity"><a class="docs-heading-anchor" href="#meshconnectivity"><code>meshconnectivity</code></a><a id="meshconnectivity-1"></a><a class="docs-heading-anchor-permalink" href="#meshconnectivity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.meshconnectivity" href="#Comodo.meshconnectivity"><code>Comodo.meshconnectivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meshconnectivity(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}) where N where TF&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Returns all mesh connectivity data</p><p><strong>Description</strong></p><p>This function returns the <code>ConnectivitySet</code>, i.e. all mesh connectivity data for  the input mesh defined by the faces <code>F</code> and the vertices <code>V</code>.  The <code>ConnectivitySet</code> contains the following connectivity descriptions: </p><ul><li>face-edge</li><li>edge-face</li><li>face-face</li><li>face-face (wrt vertices)</li><li>vertex-face</li><li>vertex-edge</li><li>edge-edge</li><li>vertex-vertex</li><li>vertex-vertex (wrt faces)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2343-L2361">source</a></section></article><h2 id="mergevertices"><a class="docs-heading-anchor" href="#mergevertices"><code>mergevertices</code></a><a id="mergevertices-1"></a><a class="docs-heading-anchor-permalink" href="#mergevertices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.mergevertices" href="#Comodo.mergevertices"><code>Comodo.mergevertices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mergevertices(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}; roundVertices = true, numDigitsMerge=nothing) where N where TF&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Merges points that coincide</p><p><strong>Description</strong></p><p>This function take the faces <code>F</code> and vertices <code>V</code> and merges points that are sufficiently  similar. Once points are merged the indices in <code>F</code> are corrected for the new reduced point set. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2398-L2407">source</a></section></article><h2 id="smoothmesh_laplacian"><a class="docs-heading-anchor" href="#smoothmesh_laplacian"><code>smoothmesh_laplacian</code></a><a id="smoothmesh_laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#smoothmesh_laplacian" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.smoothmesh_laplacian" href="#Comodo.smoothmesh_laplacian"><code>Comodo.smoothmesh_laplacian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothmesh_laplacian(F,V,con_V2V=nothing; n=1, λ=0.5)</code></pre><p><strong>Description</strong></p><p>This function implements weighted Laplacian mesh smoothing. At each  iteration, this method replaces each point by an updated coordinate based on the  mean coordinates of that point&#39;s Laplacian umbrella. The update features a lerp like weighting between the previous iterations coordinates and the mean  coordinates. The code features <code>Vs[q] = (1.0-λ).*Vs[q] .+ λ*mean(V[con_V2V[q]])</code> As can be seen, the weighting is controlled by the input parameter <code>λ</code> which is in the range (0,1). If <code>λ=0</code> then no smoothing occurs. If <code>λ=1</code> then pure  Laplacian mean based smoothing occurs. For intermediate values a linear blending between the two occurs.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2491-L2505">source</a></section></article><h2 id="smoothmesh_hc"><a class="docs-heading-anchor" href="#smoothmesh_hc"><code>smoothmesh_hc</code></a><a id="smoothmesh_hc-1"></a><a class="docs-heading-anchor-permalink" href="#smoothmesh_hc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.smoothmesh_hc" href="#Comodo.smoothmesh_hc"><code>Comodo.smoothmesh_hc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothmesh_hc(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}, n=1, α=0.1, β=0.5; con_V2V=nothing, tolDist=nothing, constrained_points=nothing) where N where TF&lt;:Integer where ND where TV&lt;:Real</code></pre><p><strong>Description</strong></p><p>This function implements HC (Humphrey&#39;s Classes) smoothing [1]. This method uses Laplacian like smoothing but aims to compensate for shrinkage/swelling by also  &quot;pushing back&quot; towards the original coordinates. </p><p><strong>Reference</strong></p><ol><li><a href="https://doi.org/10.1111/1467-8659.00334">Vollmer et al., <em>Improved Laplacian Smoothing of Noisy Surface Meshes</em>, 1999. doi: 10.1111/1467-8659.00334</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2556-L2567">source</a></section></article><h2 id="quadplate"><a class="docs-heading-anchor" href="#quadplate"><code>quadplate</code></a><a id="quadplate-1"></a><a class="docs-heading-anchor-permalink" href="#quadplate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.quadplate" href="#Comodo.quadplate"><code>Comodo.quadplate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadplate(plateDim,plateElem; orientation=:up)</code></pre><p>Returns a quad mesh for a plate</p><p><strong>Description</strong></p><p>This function creates a quadrilateral mesh (faces <code>F</code> and vertices <code>V</code>) for a  plate. The dimensions in the x-, and y-direction are specified in the input vector  <code>plateDim</code>, and the number of elements to use in each direction in the input  vector <code>plateElem</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2635-L2645">source</a></section></article><h2 id="quadsphere"><a class="docs-heading-anchor" href="#quadsphere"><code>quadsphere</code></a><a id="quadsphere-1"></a><a class="docs-heading-anchor-permalink" href="#quadsphere" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.quadsphere" href="#Comodo.quadsphere"><code>Comodo.quadsphere</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadsphere(n::Int,r::T) where T &lt;: Real</code></pre><p>Returns a quadrangulated sphere</p><p><strong>Description</strong></p><p>This function creates a quadrilateral mesh (faces <code>F</code> and vertices <code>V</code>) for a sphere with a radius defined by the input <code>r</code>. The input <code>n</code> defines the density of sphere mesh. The quad mesh is constructed using <code>subquad</code> subdivision of a regular cube,  whereby <code>n</code> sets the number of splitting iterations to use. Using <code>n=0</code> therefore returns a cube.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2673-L2684">source</a></section></article><h2 id="loflinear"><a class="docs-heading-anchor" href="#loflinear"><code>loflinear</code></a><a id="loflinear-1"></a><a class="docs-heading-anchor-permalink" href="#loflinear" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.loftlinear" href="#Comodo.loftlinear"><code>Comodo.loftlinear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loftlinear(V1,V2;num_steps=2,close_loop=true,face_type=:tri)</code></pre><p>Lofts surface between curves</p><p><strong>Description</strong></p><p>The <code>loftlinear</code> function spans a surface from input curve <code>V1</code> to curve <code>V2</code>.  The surface is formed by &quot;lerping&quot; curves from <code>V1</code> to <code>V2</code> in <code>num_steps</code>  steps, and forming mesh faces between each curve. If <code>close_loop==true</code> then it is assumed the curves (and therefore the output surface mesh should be  closed over, i.e. that a connection should be made between each curve end and  start point. The user can request different face types for the output. The  default is <code>face_type=:tri</code> which will form isoceles triangles (or equilateral  triangles if the spacing is even) for a planar curve. The other <code>face_type</code> options supported are <code>:quad</code> (quadrilateral), and <code>:tri_slash</code>. For the  latter, triangles are formed by slashing the quads.  </p><p><strong>Arguments:</strong></p><ul><li><code>V1::Vector</code>: n-vector </li><li><code>V2::Vector</code>: n-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L2757-L2778">source</a></section></article><h2 id="pointspacingmean"><a class="docs-heading-anchor" href="#pointspacingmean"><code>pointspacingmean</code></a><a id="pointspacingmean-1"></a><a class="docs-heading-anchor-permalink" href="#pointspacingmean" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.pointspacingmean" href="#Comodo.pointspacingmean"><code>Comodo.pointspacingmean</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointspacingmean(V::Vector{Point3{Float64}})
pointspacingmean(F::Array{NgonFace{N, Int}, 1},V::Vector{Point3{Float64}}) where N</code></pre><p>The <code>pointspacingmean</code> function computes the mean spacing between points. The  input can be just the coordinate set <code>V</code>, a vector of Point3  points, or also a set of edges <code>E</code> or faces <code>F</code>. If only <code>V</code> is provided it is  assumed that <code>V</code> represents an ordered set of &quot;adjacent&quot; points, e.g. as for a  curve. If a vector of edges <code>E</code> or a vector of faces <code>F is also provided, then  the average edge length is computed. If instead a set of faces</code>F` is provided  then edges are first computed after which the mean edge spacing is return. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3371-L3382">source</a></section></article><h2 id="ray_triangle_intersect"><a class="docs-heading-anchor" href="#ray_triangle_intersect"><code>ray_triangle_intersect</code></a><a id="ray_triangle_intersect-1"></a><a class="docs-heading-anchor-permalink" href="#ray_triangle_intersect" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.ray_triangle_intersect" href="#Comodo.ray_triangle_intersect"><code>Comodo.ray_triangle_intersect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ray_triangle_intersect(F::Vector{TriangleFace{Int}},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))
ray_triangle_intersect(f::TriangleFace{Int},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))</code></pre><p><strong>Description</strong></p><p>This function can compute triangle-ray or triangle-line intersections through  the use of the &quot;Möller-Trumbore triangle-ray intersection algorithm&quot; [1]. The  required inputs are as follows: </p><p><code>F</code> an single face or a vector of faces, e.g. <code>Vector{TriangleFace{Int}}</code> <code>V</code> The triangle vertices as a vector of points, i.e. <code>Vector{Point{3, Float64}}</code> <code>ray_vector</code> The ray vector which can be <code>Vector{Point{3, Float64}}</code> or <code>Vec3{Float64}</code></p><p>The following optional input parameters can be provided:  <code>rayType = :ray</code> (default) or <code>:line</code>. This defines wether the vector is treated as a ray (extends indefinately) or as a line (finite length) <code>triSide = 1</code> (default) or <code>0</code> or <code>-1</code>.  When <code>triSide=1</code> only the inward intersections are considered, e.g. when the ray or line enters the shape (ray/line is pointing against face normal) When <code>triSide=-1</code> only the outward intersections are considered, e.g. when the ray or line exits the shape (ray/line is pointing allong face normal) When <code>triSide=0</code> both inward and outward intersections are considered. <code>tolEps = eps(Float64)</code> (default) </p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1080/10867651.1997.10487468">Möller, Tomas; Trumbore, Ben (1997). <em>Fast, Minimum Storage Ray-Triangle Intersection</em>. Journal of Graphics Tools. 2: 21-28. doi: 10.1080/10867651.1997.10487468.</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3638-L3661">source</a></section></article><h2 id="mesh_curvature_polynomial"><a class="docs-heading-anchor" href="#mesh_curvature_polynomial"><code>mesh_curvature_polynomial</code></a><a id="mesh_curvature_polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#mesh_curvature_polynomial" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.mesh_curvature_polynomial" href="#Comodo.mesh_curvature_polynomial"><code>Comodo.mesh_curvature_polynomial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh_curvature_polynomial(F::Vector{TriangleFace{Int}},V::Vector{Point3{Float64}})
mesh_curvature_polynomial(M::GeometryBasics.Mesh)</code></pre><p><strong>Description</strong></p><p>This function computes the mesh curvature at each vertex for the input mesh  defined by the face <code>F</code> and the vertices <code>V</code>. A local polynomial is fitted to  each point&#39;s &quot;Laplacian umbrella&quot; (point neighbourhood), and the curvature of  this fitted form is derived. Instead of the mesh faces and vertices one may  instead specify the <code>GeometryBasics.Mesh</code> <code>M</code> as the input. </p><p>The reference below [1] provides more detail on the algorithm. In addition, this  implementation was created with the help of <a href="https://github.com/alecjacobson/geometry-processing-curvature/blob/master/README.md">this helpful document</a>,  which features a nice overview of the theory/steps involved in this algorithm. </p><p><strong>References</strong></p><ol><li><a href="https://doi.org/10.1016/j.cagd.2004.09.004">F. Cazals and M. Pouget, <em>Estimating differential quantities using polynomial fitting of osculating jets</em>, Computer Aided Geometric Design, vol. 22, no. 2, pp. 121-146, Feb. 2005, doi: 10.1016/j.cagd.2004.09.004</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3712-L3729">source</a></section></article><h2 id="separate_vertices"><a class="docs-heading-anchor" href="#separate_vertices"><code>separate_vertices</code></a><a id="separate_vertices-1"></a><a class="docs-heading-anchor-permalink" href="#separate_vertices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.separate_vertices" href="#Comodo.separate_vertices"><code>Comodo.separate_vertices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">separate_vertices(F::Array{NgonFace{N, Int}, 1},V::Array{Point{M, T}, 1}) where N where M where T&lt;:Real
separate_vertices(M::GeometryBasics.Mesh)</code></pre><p>This function takes the input mesh defined by the faces <code>F</code> and vertices <code>V</code> and separates any shared vertices. It does this by giving each face its own set of  unshared vertices. Note that any unused points are not returned in the output  point array <code>Vn</code>. Indices for the mapping are not created here but can simply be obtained using <code>reduce(vcat,F)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3810-L3819">source</a></section></article><h2 id="evenly_sample"><a class="docs-heading-anchor" href="#evenly_sample"><code>evenly_sample</code></a><a id="evenly_sample-1"></a><a class="docs-heading-anchor-permalink" href="#evenly_sample" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.evenly_sample" href="#Comodo.evenly_sample"><code>Comodo.evenly_sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evenly_sample(V::Vector{Point{ND,TV}}, n::Int; rtol = 1e-8, niter = 1) where ND where TV&lt;:Real</code></pre><p>Evenly samples curves. </p><p><strong>Description</strong></p><p>This function aims to evenly resample the input curve defined by the ND points  <code>V</code> using <code>n</code> points. The function returns the resampled points as well as the  spline interpolator <code>S</code> used. The output points can also be retriebed by using:  <code>S.(range(0.0, 1.0, n))</code>.  Note that the even sampling is defined in terms of the curve length for a 4th  order natural B-spline that interpolates the input data. Hence if significant  curvature exists for the B-spline between two adjacent data points then the  spacing between points in the output may be non-uniform (despite the allong  B-spline distance being uniform). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3862-L3878">source</a></section></article><h2 id="invert_faces"><a class="docs-heading-anchor" href="#invert_faces"><code>invert_faces</code></a><a id="invert_faces-1"></a><a class="docs-heading-anchor-permalink" href="#invert_faces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.invert_faces" href="#Comodo.invert_faces"><code>Comodo.invert_faces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert_faces(F::Vector{NgonFace{N, TF}, 1}) where N where TF&lt;:Integer</code></pre><p>Flips face orientations.</p><p><strong>Description</strong></p><p>This function inverts the faces in <code>F</code>, such that the face normal will be  flipped, by reversing the node order for each face. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3984-L3993">source</a></section></article><h2 id="kabsch_rot"><a class="docs-heading-anchor" href="#kabsch_rot"><code>kabsch_rot</code></a><a id="kabsch_rot-1"></a><a class="docs-heading-anchor-permalink" href="#kabsch_rot" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.kabsch_rot" href="#Comodo.kabsch_rot"><code>Comodo.kabsch_rot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R = kabsch_rot(V1::Array{Point{N, T}, 1},V2::Array{Point{N, TT}, 1}) where N where T&lt;:Real where TT&lt;:Real</code></pre><p><strong>Description</strong></p><p>Computes the rotation tensor <code>R</code> to rotate the points in <code>V1</code> to best match the  points in <code>V2</code>. </p><p><strong>Reference</strong></p><p><a href="https://doi.org/10.1107/S0567739476001873">Wolfgang Kabsch, <em>A solution for the best rotation to relate two sets of vectors</em>, Acta Crystallographica Section A, vol. 32, no. 5, pp. 922-923, 1976, doi: 10.1107/S0567739476001873</a>  <a href="https://en.wikipedia.org/wiki/Kabsch_algorithm">https://en.wikipedia.org/wiki/Kabsch_algorithm</a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L3999-L4009">source</a></section></article><h2 id="sweeploft"><a class="docs-heading-anchor" href="#sweeploft"><code>sweeploft</code></a><a id="sweeploft-1"></a><a class="docs-heading-anchor-permalink" href="#sweeploft" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.sweeploft" href="#Comodo.sweeploft"><code>Comodo.sweeploft</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">F,V = sweeploft(Vc,V1,V2; face_type=:quad, num_twist = 0, close_loop=true)</code></pre><p><strong>Description</strong></p><p>This function implements swept lofting. The start curve <code>V1</code> is pulled allong the  guide curve <code>Vc</code> while also gradually (linearly) morphing into the end curve  <code>V2</code>.  The optional parameter <code>face_type</code> (default :quad) defines the type of mesh  faces uses. The same face types as <code>loftlinear</code> and <code>extrudecurve</code> are supported,  i.e. <code>:quad</code>, <code>:tri_slash</code>, <code>tri</code>, or <code>quad2tri</code>.  The optional parameter <code>num_twist</code> (default is 0) can be used to add an integer  number (negative or positive) of full twists to the loft.  Finally the optional parameter <code>close_loop</code> (default is <code>true</code>) determines if the section curves are deemed closed or open ended. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4034-L4048">source</a></section></article><h2 id="revolvecurve"><a class="docs-heading-anchor" href="#revolvecurve"><code>revolvecurve</code></a><a id="revolvecurve-1"></a><a class="docs-heading-anchor-permalink" href="#revolvecurve" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.revolvecurve" href="#Comodo.revolvecurve"><code>Comodo.revolvecurve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">revolvecurve(Vc::Vector{Point{ND,TV}}; extent = 2.0*pi, direction=:positive, n=Vec{3, Float64}(0.0,0.0,1.0),num_steps=nothing,close_loop=true,face_type=:quad)  where ND where TV&lt;:Real</code></pre><p>Revolves curves to build surfaces </p><p><strong>Description</strong></p><p>This function rotates the curve <code>Vc</code> by the angle <code>extent</code>, in the direction  defined by <code>direction</code> (<code>:positive</code>, <code>:negative</code>, <code>:both</code>), around the vector  <code>n</code>, to build the output mesh defined by the faces <code>F</code> and vertices <code>V</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4142-L4152">source</a></section></article><h2 id="batman"><a class="docs-heading-anchor" href="#batman"><code>batman</code></a><a id="batman-1"></a><a class="docs-heading-anchor-permalink" href="#batman" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.batman" href="#Comodo.batman"><code>Comodo.batman</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batman(n::Int)</code></pre><p><strong>Description</strong></p><p>The <code>batman</code> function creates points on the curve for the Batman logo. The curve is useful for testing surface meshing algorithms since it contains sharp  transitions and pointy features. The user requests <code>n</code> points on the curve. The default forces exactly <code>n</code> points which may result in an assymetric curve. To  instead force symmetry the user can set the optional parameter <code>symmetric=true</code>.  In this case the output will be symmetric allong the y-axis, however the number of points on the curve may have increased (if the input <code>n</code> is not even). The second optional input is the direction of the curve, i.e. if it is clockwise,  <code>dir=:cw</code> or anti-clockwise <code>dir=:acw</code>.  The implementation is based on a &quot;parameterised Batman equation&quot; <a href="https://www.desmos.com/calculator/ajnzwedvql">1</a>. The following modifications where made, the curve is here centered around  [0,0,0], scaled to be 2 in width, resampled evenly, and the default curve  direction is anti-clockwise. </p><p><strong>References</strong></p><ol><li>https://www.desmos.com/calculator/ajnzwedvql</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4191-L4210">source</a></section></article><h2 id="tridisc"><a class="docs-heading-anchor" href="#tridisc"><code>tridisc</code></a><a id="tridisc-1"></a><a class="docs-heading-anchor-permalink" href="#tridisc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tridisc" href="#Comodo.tridisc"><code>Comodo.tridisc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tridisc(r=1.0,n=0; ngon=6, method = :linear, orientation=:up)</code></pre><p><strong>Description</strong></p><p>Generates the faces <code>F</code> and vertices <code>V</code> for a triangulated disc (circle). The  algorithm starts with a triangulated hexagon (obtained if <code>n=0</code>) and uses  iterative subtriangulation, and uses iterative subdivision (and pushing of  boundary points to circular boundary) to obtain the final mesh. The subdivision <code>method</code> is an optional input, and is either <code>:Loop</code> (default) or <code>:linear</code>.  Lastly the optional input <code>orientation</code>, which can be <code>:up</code> or <code>:down</code> sets the  face normal direction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4250-L4262">source</a></section></article><h2 id="regiontrimesh"><a class="docs-heading-anchor" href="#regiontrimesh"><code>regiontrimesh</code></a><a id="regiontrimesh-1"></a><a class="docs-heading-anchor-permalink" href="#regiontrimesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.regiontrimesh" href="#Comodo.regiontrimesh"><code>Comodo.regiontrimesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regiontrimesh(VT,R,P)</code></pre><p><strong>Description</strong></p><p>Generates a multi-region triangle mesh for the input regions. The boundary  curves for all regions are containedin the tuple <code>VT</code>. Each region to be meshed is next defined using a tuple <code>R</code> containing indices into the curve typle <code>VT</code>.  If an entry in <code>R</code> contains only one index then the entire curve domain is  meshed. If <code>R</code> contains multiple indices then the first index is assumed to be  for the outer boundary curve, while all subsequent indices are for boundaries  defining holes in this region. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4368-L4380">source</a></section></article><h2 id="scalesimplex"><a class="docs-heading-anchor" href="#scalesimplex"><code>scalesimplex</code></a><a id="scalesimplex-1"></a><a class="docs-heading-anchor-permalink" href="#scalesimplex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.scalesimplex" href="#Comodo.scalesimplex"><code>Comodo.scalesimplex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scalesimplex(F,V,s)</code></pre><p>Scales faces (or general simplices) wrt their centre. </p><p><strong>Description</strong></p><p>This function scales each simplex (e.g. a face) wrt their centre (mean of  coordinates). This function is useful in generating lattice structures from  elements as well as to create visualisations whereby &quot;looking into&quot; the mesh is needed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4495-L4505">source</a></section></article><h2 id="subcurve"><a class="docs-heading-anchor" href="#subcurve"><code>subcurve</code></a><a id="subcurve-1"></a><a class="docs-heading-anchor-permalink" href="#subcurve" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.subcurve" href="#Comodo.subcurve"><code>Comodo.subcurve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subcurve(V,n)</code></pre><p>Adds <code>n</code> points between each curve point.  </p><p><strong>Description</strong></p><p>This function adds <code>n</code> points between each current point on the curve <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4521-L4529">source</a></section></article><h2 id="dualclad"><a class="docs-heading-anchor" href="#dualclad"><code>dualclad</code></a><a id="dualclad-1"></a><a class="docs-heading-anchor-permalink" href="#dualclad" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.dualclad" href="#Comodo.dualclad"><code>Comodo.dualclad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dualclad(F::Vector{NgonFace{N, TF}},V::Vector{Point{ND,TV}},s::T; connectivity=:face) where N where TF&lt;:Integer where ND where TV&lt;:Real where T&lt;:Real</code></pre><p>Returns a surface conforming dual lattice</p><p><strong>Description</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4543-L4550">source</a></section></article><h2 id="tet2hex"><a class="docs-heading-anchor" href="#tet2hex"><code>tet2hex</code></a><a id="tet2hex-1"></a><a class="docs-heading-anchor-permalink" href="#tet2hex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tet2hex" href="#Comodo.tet2hex"><code>Comodo.tet2hex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tet2hex(E::Vector{Tet4{T}},V::Vector{Point{ND,TV}}) where T&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Converts tetrahedra to hexahedra</p><p><strong>Description</strong></p><p>This function converts the input tetrahedra defined by the element set <code>E</code> and the  vertex set <code>V</code> to a set of hexahedral elements <code>Eh</code> with vertices <code>Vh</code>. The conversion involves a splitting of each tetrahedron into 4 hexahedra. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4625-L4634">source</a></section></article><h2 id="element2faces"><a class="docs-heading-anchor" href="#element2faces"><code>element2faces</code></a><a id="element2faces-1"></a><a class="docs-heading-anchor-permalink" href="#element2faces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.element2faces" href="#Comodo.element2faces"><code>Comodo.element2faces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">element2faces(E::Vector{Element{N,T}}) where N where T</code></pre><p>Returns element faces</p><p><strong>Description</strong></p><p>This function computes the faces for the input elements defined by <code>E</code>. The elements should be Vectors consisting of <code>Tet4</code>, <code>Hex8</code> elements. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4686-L4694">source</a></section></article><h2 id="subhex"><a class="docs-heading-anchor" href="#subhex"><code>subhex</code></a><a id="subhex-1"></a><a class="docs-heading-anchor-permalink" href="#subhex" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.subhex" href="#Comodo.subhex"><code>Comodo.subhex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subhex(E::Vector{Hex8{T}},V::Vector{Point{ND,TV}},n::Int; direction=0) where T&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Split hexahedral elements</p><p><strong>Description</strong></p><p>This function splits the hexahedral elements defined by the elements <code>E</code> and  vertices <code>V</code>. Splitting is done <code>n</code> times as requested. By default the splitting  occurs in all direction (corresponding to the default <code>direction=0</code>). If instead <code>direction</code> is set to 1, 2, or 3, then the splitting only occur in the first, second or third local element direction respectively. Note that this direction depends  on node order used. For a hexahedron where by nodes 1:4 are for the bottom, and  nodes 5:8 are for the top of the element then the directions 1, 2, and 3 correspond  to the x-, y-, and z-direction respectively.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4796-L4810">source</a></section></article><h2 id="rhombicdodecahedron"><a class="docs-heading-anchor" href="#rhombicdodecahedron"><code>rhombicdodecahedron</code></a><a id="rhombicdodecahedron-1"></a><a class="docs-heading-anchor-permalink" href="#rhombicdodecahedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.rhombicdodecahedron" href="#Comodo.rhombicdodecahedron"><code>Comodo.rhombicdodecahedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rhombicdodecahedron(r = 1.0)</code></pre><p>Creates mesh for rhombicdodecahedron</p><p><strong>Description</strong></p><p>This function creates the faces <code>F</code> and vertices <code>V</code> for a rhombicdodecahedron.  The size of the shape is set by the width <code>w</code> in the xy-plane. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L4970-L4978">source</a></section></article><h2 id="tri2quad"><a class="docs-heading-anchor" href="#tri2quad"><code>tri2quad</code></a><a id="tri2quad-1"></a><a class="docs-heading-anchor-permalink" href="#tri2quad" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tri2quad" href="#Comodo.tri2quad"><code>Comodo.tri2quad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tri2quad(F,V; method=:split)</code></pre><p>Converts triangles to quads</p><p><strong>Description</strong></p><p>This function converts the input triangular mesh, defined by the faces <code>F</code> and  vertices <code>V</code>, to a quadrangulation. The method for this conversion is set using the attribute <code>method</code> which can be set to <code>:split</code>, splitting each triangle  into 3 quads by introducing a new central node, or <code>:rhombic</code>. whereby each  triangle edge is used to construct a rhombic quadrilateral face. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5020-L5031">source</a></section></article><h2 id="tetgenmesh"><a class="docs-heading-anchor" href="#tetgenmesh"><code>tetgenmesh</code></a><a id="tetgenmesh-1"></a><a class="docs-heading-anchor-permalink" href="#tetgenmesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tetgenmesh" href="#Comodo.tetgenmesh"><code>Comodo.tetgenmesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tetgenmesh(F::Array{NgonFace{N,TF}, 1},V::Vector{Point{3,TV}}; facetmarkerlist=nothing, V_regions=nothing,region_vol=nothing,V_holes=nothing,stringOpt=&quot;paAqYQ&quot;)  where N where TF&lt;:Integer where TV&lt;:Real</code></pre><p>Creates a tetrahedral mesh</p><p><strong>Description</strong></p><p>This function uses the TetGen.jl library to mesh the input geometry defined by  the faces <code>F</code> and the vertices <code>V</code> using tetrahedral elements. Several optional input parameters are available: </p><ul><li><code>facetmarkerlist</code>, a vector of integers with the same length as <code>F</code> and defines a face label for each face. </li><li><code>V_regions</code>, a vector of points inside regions which require tetrahedral meshing.</li><li><code>region_vol</code>, a vector of scalar values to denote the desired tetrahedral volume for each region.  </li><li><code>V_holes</code>, a vector of points inside holes (voids) that should remain empty. </li><li><code>stringOpt</code>, the TetGen command string to use. See also the TetGen documentation. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5085-L5100">source</a></section></article><h2 id="surfacevolume"><a class="docs-heading-anchor" href="#surfacevolume"><code>surfacevolume</code></a><a id="surfacevolume-1"></a><a class="docs-heading-anchor-permalink" href="#surfacevolume" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.surfacevolume" href="#Comodo.surfacevolume"><code>Comodo.surfacevolume</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surfacevolume(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}) where N where TF&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Computes closed surface volume</p><p><strong>Description</strong></p><p>This function computes the volume of a closed surface defined by the faces <code>F</code>  and the vertices <code>V</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5158-L5166">source</a></section></article><h2 id="tetvolume"><a class="docs-heading-anchor" href="#tetvolume"><code>tetvolume</code></a><a id="tetvolume-1"></a><a class="docs-heading-anchor-permalink" href="#tetvolume" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tetvolume" href="#Comodo.tetvolume"><code>Comodo.tetvolume</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tetvolume(E::Vector{Tet4{T}},V::Vector{Point{ND,TV}}) where T&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Computes tetrahedral volumes</p><p><strong>Description</strong></p><p>This function computes the volume for each tetrahedron defined by the input <code>E</code>,  a vector of Tet4 elements, and <code>V</code> the point coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5180-L5188">source</a></section></article><h2 id="extrudefaces"><a class="docs-heading-anchor" href="#extrudefaces"><code>extrudefaces</code></a><a id="extrudefaces-1"></a><a class="docs-heading-anchor-permalink" href="#extrudefaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.extrudefaces" href="#Comodo.extrudefaces"><code>Comodo.extrudefaces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrudefaces(F::Vector{NgonFace{NF,TF}},V::Vector{Point{ND,TV}}; extent=1.0, direction=:positive, num_steps=2, N::Union{Vector{Point{ND,TN}},Vector{Vec{ND, TN}},Nothing}=nothing) where NF where TF&lt;:Integer where ND where TV&lt;:Real where TN&lt;:Real</code></pre><p>Extrudes/thickens faces to form elements</p><p><strong>Description</strong></p><p>The inputs surface mesh, defined by the faces <code>F</code> and vertices <code>V</code> is extruded to create volumetric elements. Quadrilateral and triangular input faces are supported.  These extrude into hexahedral and pentahedral elements respectively.  The following input parameters are defined: </p><ul><li><code>extent&lt;:Real</code> (default = 1.0) the length of the extrusion   </li><li><code>direction</code> is a symbol that is either <code>:positive</code> (default), <code>:negative</code>, or <code>:both</code>. </li><li><code>N</code> The extrusion vectors. The default is nothing in which case the local </li></ul><p>vertex normals are used. </p><ul><li><code>num_steps</code> (default is 2) is the number of nodes in the extrude direction, the </li></ul><p>number of elements in the extrude direction is therefore <code>num_steps-1</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5197-L5213">source</a></section></article><h2 id="filletcurve"><a class="docs-heading-anchor" href="#filletcurve"><code>filletcurve</code></a><a id="filletcurve-1"></a><a class="docs-heading-anchor-permalink" href="#filletcurve" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.filletcurve" href="#Comodo.filletcurve"><code>Comodo.filletcurve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filletcurve(V::Vector{Point{NV,TV}}; rMax::Union{Vector{T},T,Nothing}=nothing, constrain_method = :max, n=25, close_loop = false, eps_level = 1e-6) where TV&lt;:Real where NV where T&lt;:Real</code></pre><p>Fillets/rounds curves</p><p><strong>Description</strong></p><p>The function takes in a curve defined by the points <code>V</code> and applies filleting (or rounding) to each &quot;corner&quot; (i.e. a point between two neighbouring points).  The maximum radius <code>rMax</code> is used as the largest possible radius to use. If this,  radius is not possible (e.g. if input points are too close), then a lower Radius is used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5270-L5281">source</a></section></article><h2 id="squircle"><a class="docs-heading-anchor" href="#squircle"><code>squircle</code></a><a id="squircle-1"></a><a class="docs-heading-anchor-permalink" href="#squircle" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.squircle" href="#Comodo.squircle"><code>Comodo.squircle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">squircle(r::T,n::Int,τ=0.5; atol=1e-6, dir=:acw) where T &lt;: Real</code></pre><p>Creates the squircle curve</p><p><strong>Description</strong></p><p>This function returns <code>n</code> points on a squircle. The squircle curve is defined  using the radius <code>r</code>, and the parameter <code>τ</code>. The latter controls the morphing  between a circle (<code>τ=0</code>) and square (<code>τ=1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5424-L5433">source</a></section></article><h2 id="circlerange"><a class="docs-heading-anchor" href="#circlerange"><code>circlerange</code></a><a id="circlerange-1"></a><a class="docs-heading-anchor-permalink" href="#circlerange" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.circlerange" href="#Comodo.circlerange"><code>Comodo.circlerange</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circlerange(n::Int; dir=:acw, deg=false)</code></pre><p>Creates circular angles</p><p><strong>Description</strong></p><p>This function returns <code>n</code> angles for an even circular distribution of points.  The optional input <code>dir</code> can be set to <code>:acw</code> (default) resulting in an  anti-clockwise set of angles, and can be set to <code>:cw</code> for a clockwise set of  angles. Angles are returned in radians since <code>deg</code> is <code>false</code> by default.  Using <code>deg=true</code> results in angles in degrees. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5466-L5477">source</a></section></article><h2 id="edgefaceangles"><a class="docs-heading-anchor" href="#edgefaceangles"><code>edgefaceangles</code></a><a id="edgefaceangles-1"></a><a class="docs-heading-anchor-permalink" href="#edgefaceangles" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.edgefaceangles" href="#Comodo.edgefaceangles"><code>Comodo.edgefaceangles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edgefaceangles(F::Vector{NgonFace{NF,TF}},V::Vector{Point{ND,TV}}; deg=false) where NF where TF&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Computed angles between faces</p><p><strong>Description</strong></p><p>This function computes the angle between two faces for each unique edge in the  mesh specified by <code>F</code> and the vertices <code>V</code>. If the input mesh consists of n  unique edges then the output features n angles. For boundary edges, where no pair of faces exists, the angle returned is NaN. The default behaviour results in angles being computed in radians. However by specifying <code>deg=true</code> the user can request degrees instead. Finally two additional outputs are created, namely the unique edge vector <code>E_uni</code> as well as the edge-to-face connectivity vector <code>,con_E2F</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5497-L5511">source</a></section></article><h2 id="faceanglesegment"><a class="docs-heading-anchor" href="#faceanglesegment"><code>faceanglesegment</code></a><a id="faceanglesegment-1"></a><a class="docs-heading-anchor-permalink" href="#faceanglesegment" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.faceanglesegment" href="#Comodo.faceanglesegment"><code>Comodo.faceanglesegment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">faceanglesegment(F::Vector{NgonFace{NF,TF}},V::Vector{Point{ND,TV; deg=false, angleThreshold = pi/8, indStart = 1)  where NF where TF&lt;:Integer where ND where TV&lt;:Real</code></pre><p>Segments surfaces using face angles</p><p><strong>Description</strong></p><p>This function takes in a surface mesh defined by the faces <code>F</code> and the vertices  <code>V</code>, and segments the surface mesh based on face angles. The output consists of  a &quot;feature label&quot; vector <code>G</code> (a Vector{Int}, with the same length of <code>F</code>)  whereby adjacent faces whosee angle is smaller or equal to the <code>angleThreshold</code>  (default is pi/8) receive the same label. Hence this function allows one to find  all faces with a similar orientation, for instance all top or side faces of some  mesh. The function uses radians by default. However, buy specifying the optional  parameter <code>deg=true</code> the user request that angles and the <code>angleThreshold</code> are in degrees.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5549-L5564">source</a></section></article><h2 id="eulerchar"><a class="docs-heading-anchor" href="#eulerchar"><code>eulerchar</code></a><a id="eulerchar-1"></a><a class="docs-heading-anchor-permalink" href="#eulerchar" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.eulerchar" href="#Comodo.eulerchar"><code>Comodo.eulerchar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eulerchar(F,V=nothing; E=nothing)</code></pre><p>Computes the Euler characteristic</p><p><strong>Description</strong></p><p>This function computes the Euler characteristic for the input surface defined by  the faces <code>F</code> and vertices <code>V</code>. The edges <code>E</code> are on optional input.  The Euler characteristic is defined as:  <code>X = nV-nE-nF</code> , where <code>nV</code>, <code>nE</code>, and <code>nF</code> define the number of surface vertices, edges, and  faces respectively. It is assumed all inputs are set of unique entities, e.g.  no vertices, edges, or faces occur multiple times. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5614-L5627">source</a></section></article><h2 id="rhombicdodecahedronfoam"><a class="docs-heading-anchor" href="#rhombicdodecahedronfoam"><code>rhombicdodecahedronfoam</code></a><a id="rhombicdodecahedronfoam-1"></a><a class="docs-heading-anchor-permalink" href="#rhombicdodecahedronfoam" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.rhombicdodecahedronfoam" href="#Comodo.rhombicdodecahedronfoam"><code>Comodo.rhombicdodecahedronfoam</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rhombicdodecahedronfoam(w::T,n::Union{Tuple{Vararg{Int, 3}}, Array{Int, 3}}; merge = true, orientation = :allign) where T&lt;:Real</code></pre><p>Creates a rhombicdodecahedron foam</p><p><strong>Description</strong></p><p>This function creates a rhombicdodecahedron foam structure with a desired number of cells in each direction. The input is the cell width <code>w</code> and a 1-by-3 tuple  <code>n</code> defining the number of cells in each direction. The output consists of the  set of rhombic dodecahedron elements <code>E</code> and their vertex coordinates <code>V</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5643-L5653">source</a></section></article><h2 id="truncatedoctahedron"><a class="docs-heading-anchor" href="#truncatedoctahedron"><code>truncatedoctahedron</code></a><a id="truncatedoctahedron-1"></a><a class="docs-heading-anchor-permalink" href="#truncatedoctahedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.truncatedoctahedron" href="#Comodo.truncatedoctahedron"><code>Comodo.truncatedoctahedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncatedoctahedron(w=1.0)</code></pre><p>Creates a truncated octahedron</p><p><strong>Description</strong></p><p>This function creates a truncated octahedron. The input cell width <code>w</code> is used  to define the cell faces <code>F</code> and vertices <code>V</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5795-L5803">source</a></section></article><h2 id="kelvinfoam"><a class="docs-heading-anchor" href="#kelvinfoam"><code>kelvinfoam</code></a><a id="kelvinfoam-1"></a><a class="docs-heading-anchor-permalink" href="#kelvinfoam" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.kelvinfoam" href="#Comodo.kelvinfoam"><code>Comodo.kelvinfoam</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kelvinfoam(w::T,n::Union{Tuple{Vararg{Int, 3}}, Array{Int, 3}}; merge = true) where T&lt;:Real</code></pre><p>Creates a Kelvin foam</p><p><strong>Description</strong></p><p>This function creates a Kelvin foam structure with a desired number of cells in each direction. The input is the cell width <code>w</code> and a 1-by-3 tuple <code>n</code> defining the number of cells in each direction. The output consists of the set of  truncated octahedron elements <code>E</code> and their vertex coordinates <code>V</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5863-L5873">source</a></section></article><h2 id="minp"><a class="docs-heading-anchor" href="#minp"><code>minp</code></a><a id="minp-1"></a><a class="docs-heading-anchor-permalink" href="#minp" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.minp" href="#Comodo.minp"><code>Comodo.minp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minp(V::Vector{Point{N,T}}) where N where T &lt;:Real</code></pre><p>Returns minimum coordinates</p><p><strong>Description</strong></p><p>This function computes the minimum coordinates for all points. Points can be  N-dimensional and the output is another point of the same dimensionality but  with the lowest coordinate value for each direction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5951-L5960">source</a></section></article><h2 id="maxp"><a class="docs-heading-anchor" href="#maxp"><code>maxp</code></a><a id="maxp-1"></a><a class="docs-heading-anchor-permalink" href="#maxp" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.maxp" href="#Comodo.maxp"><code>Comodo.maxp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxp(V::Vector{Point{N,T}}) where N where T &lt;:Real</code></pre><p>Returns maximum coordinates</p><p><strong>Description</strong></p><p>This function computes the maximum coordinates for all points. Points can be  N-dimensional and the output is another point of the same dimensionality but  with the highest coordinate value for each direction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5971-L5980">source</a></section></article><h2 id="ntrapezohedron"><a class="docs-heading-anchor" href="#ntrapezohedron"><code>ntrapezohedron</code></a><a id="ntrapezohedron-1"></a><a class="docs-heading-anchor-permalink" href="#ntrapezohedron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.ntrapezohedron" href="#Comodo.ntrapezohedron"><code>Comodo.ntrapezohedron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ntrapezohedron(n,r=1.0)</code></pre><p>Constructs an n-trapezohedron</p><p><strong>Description</strong></p><p>This function creates the faces <code>F</code> and vertices <code>V</code> for an n-trapezohedron. </p><p>The implementation is based on the equations presented here:  https://mathworld.wolfram.com/Trapezohedron.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L5991-L6001">source</a></section></article><h2 id="spacing2numvertices"><a class="docs-heading-anchor" href="#spacing2numvertices"><code>spacing2numvertices</code></a><a id="spacing2numvertices-1"></a><a class="docs-heading-anchor-permalink" href="#spacing2numvertices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.spacing2numvertices" href="#Comodo.spacing2numvertices"><code>Comodo.spacing2numvertices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spacing2numvertices(F::Vector{TriangleFace{TF}},V::Vector{Point{ND,TV}},pointSpacing::TP) where TF&lt;:Integer where ND where TV&lt;:Real where TP&lt;:Real</code></pre><p>Point numbers from spacing</p><p><strong>Description</strong></p><p>This function helps to determine what number of vertices to resample a surface  with to obtain a desired point spacing. The input consists of in initial surface , defined by the faces <code>F</code> and the vertices <code>V</code>, and also the desired point  spacing <code>pointSpacing</code>. Next the function uses the surface Euler characteristic as well as knowledge of face area and point spacing changes for homogeneous  face splitting (e.g. via <code>subtri</code><code>), to determine the theoretical number of  points</code>NV` a resampled surface should have to present with the desired point spacing. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L6035-L6049">source</a></section></article><h2 id="joingeom"><a class="docs-heading-anchor" href="#joingeom"><code>joingeom</code></a><a id="joingeom-1"></a><a class="docs-heading-anchor-permalink" href="#joingeom" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.joingeom" href="#Comodo.joingeom"><code>Comodo.joingeom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">joingeom(G...)</code></pre><p>Joins geometry</p><p><strong>Description</strong></p><p>This function joins geometry defined for instance by multiple face and vertex  sets into one such set. All geometry such be of the same type such that they can be joined. The input can for instance be n-sets of faces (or elemens) and  vertices e.g. appearing as inpus as: <code>F1,V1,F2,V2,...,FN,VN</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L6098-L6108">source</a></section></article><h2 id="quadbox"><a class="docs-heading-anchor" href="#quadbox"><code>quadbox</code></a><a id="quadbox-1"></a><a class="docs-heading-anchor-permalink" href="#quadbox" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.quadbox" href="#Comodo.quadbox"><code>Comodo.quadbox</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadbox(boxDim,boxEl)</code></pre><p>Creates quadrilateral box mesh</p><p><strong>Description</strong></p><p>This function uses the dimensions defined in <code>boxDim</code>, and the number of  elements listed for each direction in <code>boxEl</code> to create a quadrilateral mesh for  a box. The output consists of the faces <code>F</code>, the vertices <code>V</code>, and a face  labelling <code>C</code> (for the 6 sides of the box). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L6140-L6150">source</a></section></article><h2 id="tribox"><a class="docs-heading-anchor" href="#tribox"><code>tribox</code></a><a id="tribox-1"></a><a class="docs-heading-anchor-permalink" href="#tribox" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tribox" href="#Comodo.tribox"><code>Comodo.tribox</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tribox(boxDim,pointSpacing)</code></pre><p>Creates triangulated box mesh</p><p><strong>Description</strong></p><p>This function uses the dimensions defined in <code>boxDim</code>, and the desired point spacing defined by <code>pointSpacing</code>, to create a triangulated mesh for a box.  The output consists of the faces <code>F</code>, the vertices <code>V</code>, and a face  labelling <code>C</code> (for the 6 sides of the box). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L6158-L6168">source</a></section></article><h2 id="tetbox"><a class="docs-heading-anchor" href="#tetbox"><code>tetbox</code></a><a id="tetbox-1"></a><a class="docs-heading-anchor-permalink" href="#tetbox" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Comodo.tetbox" href="#Comodo.tetbox"><code>Comodo.tetbox</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tetbox(boxDim,pointSpacing; stringOpt = &quot;paAqYQ&quot;,region_vol=nothing)</code></pre><p>Creates tetrahedral box mesh</p><p><strong>Description</strong></p><p>This function uses the dimensions defined in <code>boxDim</code>, and the desired point spacing defined by <code>pointSpacing</code>, to create a tetrahedral mesh for a box.  The output consists of the elements <code>E</code>, the vertices <code>V</code>, the boundary faces  <code>Fb</code>, and the boundary face labelling <code>Cb</code> (for the 6 sides of the box). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COMODO-research/Comodo.jl/blob/17e30ab04aa082a29f5eae14cc531390660d650d/src/functions.jl#L6239-L6249">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 7 January 2025 12:18">Tuesday 7 January 2025</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
