var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#comododir","page":"Functions","title":"comododir","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.comododir","category":"page"},{"location":"functions/#Comodo.comododir","page":"Functions","title":"Comodo.comododir","text":"comododir()\n\nDescription\n\nThis function simply returns the string for the Comodo path. This is helpful for instance to load items, such as meshes, from the assets` folder. \n\n\n\n\n\n","category":"function"},{"location":"functions/#slidercontrol","page":"Functions","title":"slidercontrol","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.slidercontrol","category":"page"},{"location":"functions/#Comodo.slidercontrol","page":"Functions","title":"Comodo.slidercontrol","text":"slidercontrol(hSlider,ax)\n\nDescription\n\nThis function adds arrow key control to GLMakie sliders. The inputs are the  slider handle hSlider as well as the axis ax. If this function is called the slider can be advanced a step by pressing the right arrow, and returned one step  by pressing the left arrow. When one presses and holds the right or left arrow  key, the slider will continue to move (as fast as graphics updating is possible on your system) up to the end or start slider position respectively. Users may  also use the up or down arrow keys. These function the same as the right and  left arrow keys, however, rather than stopping at the slider extrema, the  sliders position will \"wrap\" back to the start when advancing beyond the end  position, and vice versa. \n\n\n\n\n\n","category":"function"},{"location":"functions/#elements2indices","page":"Functions","title":"elements2indices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.elements2indices","category":"page"},{"location":"functions/#Comodo.elements2indices","page":"Functions","title":"Comodo.elements2indices","text":"elements2indices(F)\n\nDescription\n\nThis function obtains the unique set of indices for the vertices (nodes)  used by the the simplices defined by F. The vector F may contain any type of  simplices. For instance the elements in F may be of the type  GeometryBasics.TriangleFace or GeometryBasics.QuadFace (or any other) for  surface mesh data. However, volumetric elements of any type are permitted. In essence this function simply returns unique(reduce(vcat,F)). Hence any suitable vector containing vectors of numbers permitted by  reduce(vcat,F) is supported. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gridpoints","page":"Functions","title":"gridpoints","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gridpoints","category":"page"},{"location":"functions/#Comodo.gridpoints","page":"Functions","title":"Comodo.gridpoints","text":"gridpoints(x::Vector{T}, y=x, z=x) where T<:Real\n\nDescription\n\nThe gridpoints function returns a vector of 3D points which span a grid in 3D  space. Points are defined as per the input ranges or range vectors. The output  point vector contains elements of the type GeometryBasics.Point3. \n\n\n\n\n\n","category":"function"},{"location":"functions/#interp_biharmonic_spline","page":"Functions","title":"interp_biharmonic_spline","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.interp_biharmonic_spline","category":"page"},{"location":"functions/#Comodo.interp_biharmonic_spline","page":"Functions","title":"Comodo.interp_biharmonic_spline","text":"interp_biharmonic_spline(x::Union{Vector{T}, AbstractRange{T}},y::Union{Vector{T}, AbstractRange{T}},xi::Union{Vector{T}, AbstractRange{T}}; extrapolate_method=:linear,pad_data=:linear) where T<:Real\n\nDescription\n\nThis function uses biharmonic spline interpolation, which features radial basis  functions. The input is assumed to represent ordered data, i.e. consequtive  unique points on a curve. The curve x-, and y-coordinates are provided through  the input parameters x and y respectively. The third input xi defines the  sites at which to interpolate. Each of in the input parameters can be either a  vector or a range. \n\nReferences\n\nDavid T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139\n\n\n\n\n\n","category":"function"},{"location":"functions/#interp_biharmonic","page":"Functions","title":"interp_biharmonic","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.interp_biharmonic","category":"page"},{"location":"functions/#Comodo.interp_biharmonic","page":"Functions","title":"Comodo.interp_biharmonic","text":"interp_biharmonic(x,y,xi)\n\nDescription\n\nThis function uses biharmonic interpolation. The input x should define a  vector consisting of m points which are n-dimensional, and the input y should be a vector consisting of m scalar data values. \n\nReferences\n\nDavid T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139\n\n\n\n\n\n","category":"function"},{"location":"functions/#nbezier","page":"Functions","title":"nbezier","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.nbezier","category":"page"},{"location":"functions/#Comodo.nbezier","page":"Functions","title":"Comodo.nbezier","text":"nbezier(P,n)\n\nDescription\n\nThis function returns n points for an m-th order Bézier spline, based on the  m control points contained in the input vector P. This function supports point vectors with elements of the type AbstractPoint{3} (e.g. GeometryBasics.Point{3, Float64}) or Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"functions/#loflinear","page":"Functions","title":"loflinear","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.loftlinear","category":"page"},{"location":"functions/#Comodo.loftlinear","page":"Functions","title":"Comodo.loftlinear","text":"loftlinear(V1,V2;num_steps=2,close_loop=true,face_type=:tri)\n\nLoft a surface mesh between two input curves\n\nDescription\n\nThe loftlinear function spans a surface from input curve V1 to curve V2.  The surface is formed by \"lerping\" curves from V1 to V2 in num_loft  steps, and forming mesh faces between each curve. If close_loop==true then it is assumed the curves (and therefore the output surface mesh should be  closed over, i.e. that a connection should be made between each curve end and  start point. The user can request different face types for the output. The  default is face_type=:tri which will form isoceles triangles (or equilateral  triangles if the spacing is even) for a planar curve. The other face_type options supported are :quad (quadrilateral), and :tri_slash. For the  latter, triangles are formed by slashing the quads.  \n\nArguments:\n\nV1::Vector: n-vector \nV2::Vector: n-vector\n\n\n\n\n\n","category":"function"},{"location":"functions/#ray_triangle_intersect","page":"Functions","title":"ray_triangle_intersect","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ray_triangle_intersect","category":"page"},{"location":"functions/#Comodo.ray_triangle_intersect","page":"Functions","title":"Comodo.ray_triangle_intersect","text":"ray_triangle_intersect(F::Vector{TriangleFace{Int64}},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))\nray_triangle_intersect(f::TriangleFace{Int64},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))\n\nDescription\n\nThis function can compute triangle-ray or triangle-line intersections through  the use of the \"Möller-Trumbore triangle-ray intersection algorithm\". The  required inputs are as follows: \n\nF an single face or a vector of faces, e.g. Vector{TriangleFace{Int64}} V The triangle vertices as a vector of points, i.e. Vector{GeometryBasics.Point{3, Float64}} ray_vector The ray vector which can be Vector{GeometryBasics.Point{3, Float64}} or Vec3{Float64}\n\nThe following optional input parameters can be provided:  rayType = :ray (default) or :line. This defines wether the vector is treated as a ray (extends indefinately) or as a line (finite length) triSide = 1 (default) or 0 or -1.  When triSide=1 only the inward intersections are considered, e.g. when the ray or line enters the shape (ray/line is pointing against face normal) When triSide=-1 only the outward intersections are considered, e.g. when the ray or line exits the shape (ray/line is pointing allong face normal) When triSide=0 both inward and outward intersections are considered. tolEps = eps(Float64) (default) \n\nReferences\n\nMöller, Tomas; Trumbore, Ben (1997). \"Fast, Minimum Storage Ray-Triangle Intersection\". Journal of Graphics Tools. 2: 21-28. doi: 10.1080/10867651.1997.10487468.\n\n\n\n\n\n","category":"function"},{"location":"functions/#mesh_curvature_polynomial","page":"Functions","title":"mesh_curvature_polynomial","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.mesh_curvature_polynomial","category":"page"},{"location":"functions/#Comodo.mesh_curvature_polynomial","page":"Functions","title":"Comodo.mesh_curvature_polynomial","text":"mesh_curvature_polynomial(F::Vector{TriangleFace{Int64}},V::Vector{Point3{Float64}})\nmesh_curvature_polynomial(M::GeometryBasics.Mesh)\n\nDescription\n\nThis function computes the mesh curvature at each vertex for the input mesh  defined by the face F and the vertices V. A local polynomial is fitted to  each point's \"Laplacian umbrella\" (point neighbourhood), and the curvature of  this fitted form is derived. Instead of the mesh faces and vertices one may  instead specify the GeometryBasics.Mesh M as the input. \n\nThe reference below provides more detail on the algorithm. In addition, this  implementation was created with the help of this helpful document,  which features a nice overview of the theory/steps involved in this algorithm. \n\nReferences\n\nF. Cazals and M. Pouget, \"Estimating differential quantities using polynomial fitting of osculating jets\", Computer Aided Geometric Design, vol. 22, no. 2, pp. 121-146, Feb. 2005, doi: 10.1016/j.cagd.2004.09.004\n\n\n\n\n\n","category":"function"},{"location":"functions/#smoothmesh_hc","page":"Functions","title":"smoothmesh_hc","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.smoothmesh_hc","category":"page"},{"location":"functions/#Comodo.smoothmesh_hc","page":"Functions","title":"Comodo.smoothmesh_hc","text":"smoothmesh_hc(F,V, con_V2V=nothing; n=1, α=0.1, β=0.5, tolDist=nothing)\n\nDescription\n\nThis function implements HC (Humphrey's Classes) smoothing. This method uses Laplacian like smoothing but aims to compensate for shrinkage/swelling by also  \"pushing back\" towards the original coordinates. \n\nReference\n\nVollmer et al. Improved Laplacian Smoothing of Noisy Surface Meshes, 1999. doi: 10.1111/1467-8659.00334\n\n\n\n\n\n","category":"function"},{"location":"functions/#smoothmesh_laplacian","page":"Functions","title":"smoothmesh_laplacian","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.smoothmesh_laplacian","category":"page"},{"location":"functions/#Comodo.smoothmesh_laplacian","page":"Functions","title":"Comodo.smoothmesh_laplacian","text":"smoothmesh_laplacian(F,V,con_V2V=nothing; n=1, λ=0.5)\n\nDescription\n\nThis function implements weighted Laplacian mesh smoothing. At each  iteration, this method replaces each point by an updated coordinate based on the  mean coordinates of that point's Laplacian umbrella. The update features a lerp like weighting between the previous iterations coordinates and the mean  coordinates. The code features Vs[q] = (1.0-λ).*Vs[q] .+ λ*mean(V[con_V2V[q]]) As can be seen, the weighting is controlled by the input parameter λ which is in the range (0,1). If λ=0 then no smoothing occurs. If λ=1 then pure  Laplacian mean based smoothing occurs. For intermediate values a linear blending between the two occurs.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#platonicsolid","page":"Functions","title":"platonicsolid","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.platonicsolid","category":"page"},{"location":"functions/#Comodo.platonicsolid","page":"Functions","title":"Comodo.platonicsolid","text":"platonicsolid(n,r=1.0)\n\nDescription\n\nCreates a GeometryBasics mesh description for a platonic solid of choice. The  input n defines the choice.\n\ntetrahedron\ncube\noctahedron\nicosahedron\ndodecahedron\n\nThe final input parameter r defines the radius of the platonic solid (the  radius of the circumsphere to the vertices).\n\nArguments\n\nn::Integer, defining platonic solid type r::Float64, defining circumsphere radius\n\n\n\n\n\n","category":"function"},{"location":"functions/#sub2ind","page":"Functions","title":"sub2ind","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.sub2ind","category":"page"},{"location":"functions/#Comodo.sub2ind","page":"Functions","title":"Comodo.sub2ind","text":"sub2ind(siz,A)\n\nDescription\n\nConverts the subscript indices in A, for a matrix/array with size siz, to  the equivalent linear indices.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#ind2sub","page":"Functions","title":"ind2sub","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ind2sub","category":"page"},{"location":"functions/#Comodo.ind2sub","page":"Functions","title":"Comodo.ind2sub","text":"ind2sub(siz,ind)\n\nDescription\n\nConverts the linear indices in ind, for a matrix/array with size siz, to the  equivalent subscript indices.  \n\n\n\n\n\n","category":"function"},{"location":"#Comodo.jl","page":"Comodo.jl","title":"Comodo.jl","text":"","category":"section"},{"location":"","page":"Comodo.jl","title":"Comodo.jl","text":"___________________","category":"page"},{"location":"","page":"Comodo.jl","title":"Comodo.jl","text":"Functions","category":"page"}]
}
