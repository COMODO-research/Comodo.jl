var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#comododir","page":"Functions","title":"comododir","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.comododir","category":"page"},{"location":"functions/#Comodo.comododir","page":"Functions","title":"Comodo.comododir","text":"comododir()\n\nDescription\n\nThis function simply returns the string for the Comodo path. This is helpful for instance to load items, such as meshes, from the assets` folder. \n\n\n\n\n\n","category":"function"},{"location":"functions/#slidercontrol","page":"Functions","title":"slidercontrol","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.slidercontrol","category":"page"},{"location":"functions/#Comodo.slidercontrol","page":"Functions","title":"Comodo.slidercontrol","text":"slidercontrol(hSlider,ax)\n\nAdds arrow key control to sliders\n\nDescription\n\nThis function adds arrow key control to Makie sliders. The inputs are the  slider handle hSlider as well as the axis ax. If this function is called the slider can be advanced a step by pressing the right arrow, and returned one step  by pressing the left arrow. When one presses and holds the right or left arrow  key, the slider will continue to move (as fast as graphics updating is possible on your system) up to the end or start slider position respectively. Users may  also use the up or down arrow keys. These function the same as the right and  left arrow keys, however, rather than stopping at the slider extrema, the  sliders position will \"wrap\" back to the start when advancing beyond the end  position, and vice versa. \n\n\n\n\n\n","category":"function"},{"location":"functions/#slider2anim","page":"Functions","title":"slider2anim","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.slider2anim","category":"page"},{"location":"functions/#Comodo.slider2anim","page":"Functions","title":"Comodo.slider2anim","text":"slider2anim(fig::Figure,hSlider::Slider,fileName::String; backforth=true, duration=2)\n\nExports movies from slider based visualisations.\n\nDescription\n\nConverts the effect of the slider defined by the slider handle hSlider for the  figure fig to an animation/movie file\n\n\n\n\n\n","category":"function"},{"location":"functions/#elements2indices","page":"Functions","title":"elements2indices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.elements2indices","category":"page"},{"location":"functions/#Comodo.elements2indices","page":"Functions","title":"Comodo.elements2indices","text":"elements2indices(F)\n\nReturns the indices contained in F\n\nDescription\n\nThis function obtains the unique set of indices for the vertices (nodes)  used by the the simplices defined by F. The vector F may contain any type of  simplices. For instance the elements in F may be of the type  GeometryBasics.TriangleFace or GeometryBasics.QuadFace (or any other) for  surface mesh data. However, volumetric elements of any type are permitted. In essence this function simply returns unique(reduce(vcat,F)). Hence any suitable vector containing vectors of numbers permitted by  reduce(vcat,F) is supported. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gridpoints","page":"Functions","title":"gridpoints","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gridpoints","category":"page"},{"location":"functions/#Comodo.gridpoints","page":"Functions","title":"Comodo.gridpoints","text":"gridpoints(x::Vector{T}, y=x, z=x) where T<:Real\n\nReturns 3D grids of points\n\nDescription\n\nThe gridpoints function returns a vector of 3D points which span a grid in 3D  space. Points are defined as per the input ranges or range vectors. The output  point vector contains elements of the type Point. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gridpoints_equilateral","page":"Functions","title":"gridpoints_equilateral","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gridpoints_equilateral","category":"page"},{"location":"functions/#Comodo.gridpoints_equilateral","page":"Functions","title":"Comodo.gridpoints_equilateral","text":"gridpoints_equilateral(xSpan,ySpan,pointSpacing::T; return_faces = false, rectangular=false) where T <: Real\n\nReturns a \"grid\" of 3D points that are located on the corners of an equilateral triangle tesselation.\n\nDescription\n\nThis function returns 3D point data in the form of a Vector{Point{3,Float64}}.  The point distribution is for an equilateral triangle tesselation. The input  consists of the span in the x-, and y-direction, i.e. xSpan and ySpan  respectively, as well as the desired pointSpacing. The \"spans\" should be  vectors or tuples defining the minimum and maximum coordinates for the grid. The true point spacing in the x-direction is computed such that a nearest whole  number of steps can cover the required distance. Next this spacing is used to  create the equilateral triangle point grid. Although the xSpan is closely  adhered to through this method, the ySpan is not fully covered. In the  y-direction the grid does start at the minimum level, but may stop short of  reaching the maximum y as it may not be reachable in a whole number of steps  from the minimum. Optional arguments include return_faces (default is  false), which will cause the function to return triangular faces F as well  as the vertices V. Secondly the option rectangular will force the grid to  conform to a rectangular domain. This means the \"jagged\" sides are forced to be  flat such that all x-coordinates on the left are at the minimum in xSpan and all on the right are at the maximum in xSpan, however, this does result in a  non-uniform spacing at these edges.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#interp_biharmonic_spline","page":"Functions","title":"interp_biharmonic_spline","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.interp_biharmonic_spline","category":"page"},{"location":"functions/#Comodo.interp_biharmonic_spline","page":"Functions","title":"Comodo.interp_biharmonic_spline","text":"interp_biharmonic_spline(x::Union{Vector{T}, AbstractRange{T}},y::Union{Vector{T}, AbstractRange{T}},xi::Union{Vector{T}, AbstractRange{T}}; extrapolate_method=:linear,pad_data=:linear) where T<:Real\n\nInterpolates 1D (curve) data using biharmonic spline interpolation\n\nDescription\n\nThis function uses biharmonic spline interpolation [1], which features radial basis  functions. The input is assumed to represent ordered data, i.e. consequtive  unique points on a curve. The curve x-, and y-coordinates are provided through  the input parameters x and y respectively. The third input xi defines the  sites at which to interpolate. Each of in the input parameters can be either a  vector or a range. \n\nReferences\n\nDavid T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139\n\n\n\n\n\n","category":"function"},{"location":"functions/#interp_biharmonic","page":"Functions","title":"interp_biharmonic","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.interp_biharmonic","category":"page"},{"location":"functions/#Comodo.interp_biharmonic","page":"Functions","title":"Comodo.interp_biharmonic","text":"interp_biharmonic(x,y,xi)\n\nInterpolates n-dimensional data using biharmonic spline interpolation\n\nDescription\n\nThis function uses biharmonic interpolation [1]. The input x should define a  vector consisting of m points which are n-dimensional, and the input y should be a vector consisting of m scalar data values. \n\nReferences\n\nDavid T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139\n\n\n\n\n\n","category":"function"},{"location":"functions/#nbezier","page":"Functions","title":"nbezier","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.nbezier","category":"page"},{"location":"functions/#Comodo.nbezier","page":"Functions","title":"Comodo.nbezier","text":"nbezier(P,n)\n\nReturns a Bezier spline for the control points P whose order matches the numbe  of control points provided. \n\nDescription\n\nThis function returns n points for an m-th order Bézier spline, based on the  m control points contained in the input vector P. This function supports point vectors with elements of the type AbstractPoint{3} (e.g. Point{3, Float64}) or Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"functions/#lerp","page":"Functions","title":"lerp","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.lerp","category":"page"},{"location":"functions/#Comodo.lerp","page":"Functions","title":"Comodo.lerp","text":"lerp(x::Union{T,Vector{T}, AbstractRange{T}},y,xi::Union{T,Vector{T}, AbstractRange{T}}) where T <: Real\n\nLinear interpolation\n\nDescription\n\nThis linearly interpolates (lerps) the input data specified by the sites x and  data y at the specified sites xi. \n\n\n\n\n\n","category":"function"},{"location":"functions/#dist","page":"Functions","title":"dist","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.dist","category":"page"},{"location":"functions/#Comodo.dist","page":"Functions","title":"Comodo.dist","text":"dist(V1,V2)\n\nComputes n-dimensional Euclidean distances\n\nDescription\n\nFunction compute an nxm distance matrix for the n inputs points in V1, and the m input points in V2. The input points may be multidimensional, in fact they can be any type supported by the euclidean function of Distances.jl.  See also: https://github.com/JuliaStats/Distances.jl\n\n\n\n\n\n","category":"function"},{"location":"functions/#mindist","page":"Functions","title":"mindist","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.mindist","category":"page"},{"location":"functions/#Comodo.mindist","page":"Functions","title":"Comodo.mindist","text":"mindist(V1,V2; getIndex=false, skipSelf = false )\n\nReturns nearest point distances \n\nDescription\n\nReturns the closest point distance for the input points V1 with respect to the  input points V2. If the optional parameter getIndex is set to true (false  by default) then this function also returns the indices of the nearest points  in V2 for each point in V1. For self-distance evaluation, i.e. if the same  point set is provided twice, then the optional parameter skipSelf can be set  t0 true (default is false) if \"self distances\" (e.g. the nth point to the  nth point) are to be avoided.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index","page":"Functions","title":"unique_dict_index","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index","category":"page"},{"location":"functions/#Comodo.unique_dict_index","page":"Functions","title":"Comodo.unique_dict_index","text":"unique_dict_index(X::Union{Tuple{Vararg{T, N}}, Array{T, N}}; sort_entries=false) where T <: Any where N\n\nReturns unique values and indices\n\nDescription\n\nReturns the unique entries in X as well as the indices for them.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index_inverse","page":"Functions","title":"unique_dict_index_inverse","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index_inverse","category":"page"},{"location":"functions/#Comodo.unique_dict_index_inverse","page":"Functions","title":"Comodo.unique_dict_index_inverse","text":"unique_dict_index_inverse(X::Union{Tuple{Vararg{T, N}}, Array{T, N}}; sort_entries=false) where T <: Any where N\n\nReturns unique values, indices, and inverse indices\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the  reverse indices to retrieve the original from the unique entries.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index_count","page":"Functions","title":"unique_dict_index_count","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index_count","category":"page"},{"location":"functions/#Comodo.unique_dict_index_count","page":"Functions","title":"Comodo.unique_dict_index_count","text":"unique_dict_index_count(X::Union{Tuple{Vararg{T, N}}, Array{T, N}}; sort_entries=false) where T <: Any where N\n\nReturns unique values, indices, and counts\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the counts  in terms of how often they occured.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index_inverse_count","page":"Functions","title":"unique_dict_index_inverse_count","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index_inverse_count","category":"page"},{"location":"functions/#Comodo.unique_dict_index_inverse_count","page":"Functions","title":"Comodo.unique_dict_index_inverse_count","text":"unique_dict_index_inverse_count(X::Union{Tuple{Vararg{T, N}}, Array{T, N}}; sort_entries=false) where T <: Any where N\n\nReturns unique values, indices, inverse indices, and counts\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the reverse  indices to retrieve the original from the unique entries, and also the counts in  terms of how often they occured.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_count","page":"Functions","title":"unique_dict_count","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_count","category":"page"},{"location":"functions/#Comodo.unique_dict_count","page":"Functions","title":"Comodo.unique_dict_count","text":"unique_dict_count(X::Union{Tuple{Vararg{T, N}}, Array{T, N}}; sort_entries=false) where T <: Any where N\n\nReturns unique values and counts\n\nDescription\n\nReturns the unique entries in X as well as the counts in terms of how often  they occured.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_inverse","page":"Functions","title":"unique_dict_inverse","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_inverse","category":"page"},{"location":"functions/#Comodo.unique_dict_inverse","page":"Functions","title":"Comodo.unique_dict_inverse","text":"unique_dict_inverse(X::Union{Tuple{Vararg{T, N}}, Array{T, N}}; sort_entries=false) where T <: Any where N\n\nReturns unique values and inverse indices\n\nDescription\n\nReturns the unique entries in X as well as the reverse indices to retrieve the  original from the unique entries.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict","page":"Functions","title":"unique_dict","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict","category":"page"},{"location":"functions/#Comodo.unique_dict","page":"Functions","title":"Comodo.unique_dict","text":"unique_dict(X::AbstractVector{T}) where T <: Real\n\nReturns unique values, indices, and inverse indices. Uses an OrderedDict.\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the reverse  indices to retrieve the original from the unique entries. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gunique","page":"Functions","title":"gunique","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gunique","category":"page"},{"location":"functions/#Comodo.gunique","page":"Functions","title":"Comodo.gunique","text":"gunique(X; return_unique=true, return_index=false, return_inverse=false, return_counts=false, sort_entries=false)\n\nReturns unique values and allows users to choose if they also want: sorting, indices, inverse indices, and counts. \n\nDescription\n\nReturns the unique entries in X. Depending on the optional parameter choices the indices for the unique entries, the reverse indices to retrieve the original from the unique entries, as well as counts in terms of how often they occured,  can be returned.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_simplices","page":"Functions","title":"unique_simplices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_simplices","category":"page"},{"location":"functions/#Comodo.unique_simplices","page":"Functions","title":"Comodo.unique_simplices","text":"unique_simplices(F,V=nothing)\n\nReturns unique simplices (such as faces), independant of node order\n\nDescription\n\nReturns the unique simplices in F as well as the indices of the unique simplices and the reverse indices to retrieve the original faces from the unique faces.  Entries in F are sorted such that the node order does not matter. \n\n\n\n\n\n","category":"function"},{"location":"functions/#ind2sub","page":"Functions","title":"ind2sub","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ind2sub","category":"page"},{"location":"functions/#Comodo.ind2sub","page":"Functions","title":"Comodo.ind2sub","text":"ind2sub(siz,ind)\n\nConverts linear indices to subscript indices. \n\nDescription\n\nConverts the linear indices in ind, for a matrix/array with size siz, to the  equivalent subscript indices.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#sub2ind","page":"Functions","title":"sub2ind","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.sub2ind","category":"page"},{"location":"functions/#Comodo.sub2ind","page":"Functions","title":"Comodo.sub2ind","text":"sub2ind(siz,A)\n\nConverts subscript indices to linear indices. \n\nDescription\n\nConverts the subscript indices in A, for a matrix/array with size siz, to  the equivalent linear indices.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#meshedges","page":"Functions","title":"meshedges","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.meshedges","category":"page"},{"location":"functions/#Comodo.meshedges","page":"Functions","title":"Comodo.meshedges","text":"meshedges(F::Array{NgonFace{N,T},1}; unique_only=false) where N where T<:Integer\n\nReturns a mesh's edges.\n\nDescription\n\nThis function returns the edges E for the input faces defined by F.  The input F can either represent a vector of faces or a  GeometryBasics.Mesh. The convention is such that for a face referring to the  nodes 1-2-3-4, the edges are 1-2, 2-3, 3-4, 4-1.   \n\n\n\n\n\n","category":"function"},{"location":"functions/#icosahedron","page":"Functions","title":"icosahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.icosahedron","category":"page"},{"location":"functions/#Comodo.icosahedron","page":"Functions","title":"Comodo.icosahedron","text":"icosahedron(r=1.0)\n\nCreates an icosahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an icosahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#octahedron","page":"Functions","title":"octahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.octahedron","category":"page"},{"location":"functions/#Comodo.octahedron","page":"Functions","title":"Comodo.octahedron","text":"octahedron(r=1.0)\n\nCreates an octahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an octahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#dodecahedron","page":"Functions","title":"dodecahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.dodecahedron","category":"page"},{"location":"functions/#Comodo.dodecahedron","page":"Functions","title":"Comodo.dodecahedron","text":"dodecahedron(r=1.0)\n\nCreates a dodecahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an dodecahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#cube","page":"Functions","title":"cube","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.cube","category":"page"},{"location":"functions/#Comodo.cube","page":"Functions","title":"Comodo.cube","text":"cube(r=1.0)\n\nCreates a cube mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an cube with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#tetrahedron","page":"Functions","title":"tetrahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tetrahedron","category":"page"},{"location":"functions/#Comodo.tetrahedron","page":"Functions","title":"Comodo.tetrahedron","text":"tetrahedron(r=1.0)\n\nCreates a tetrahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an tetrahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#platonicsolid","page":"Functions","title":"platonicsolid","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.platonicsolid","category":"page"},{"location":"functions/#Comodo.platonicsolid","page":"Functions","title":"Comodo.platonicsolid","text":"platonicsolid(n,r=1.0)\n\nReturns a platonic solid mesh.\n\nDescription\n\nCreates a GeometryBasics mesh description for a platonic solid of choice. The  input n defines the choice.\n\ntetrahedron\ncube\noctahedron\nicosahedron\ndodecahedron\n\nThe final input parameter r defines the radius of the platonic solid (the  radius of the circumsphere to the vertices).  The default radius, when not  supplied, is 1.0. \n\nArguments\n\nn::Integer, defining platonic solid type r::Float64, defining circumsphere radius\n\n\n\n\n\n","category":"function"},{"location":"functions/#tofaces","page":"Functions","title":"tofaces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tofaces","category":"page"},{"location":"functions/#Comodo.tofaces","page":"Functions","title":"Comodo.tofaces","text":"tofaces(FM::Vector{Vector{TF}}) where TF<:Integer\ntofaces(FM::Matrix{TF})  where TF<:Integer\ntofaces(FM::Vector{NgonFace{m, OffsetInteger{-1, TF}}} ) where m where TF <: Integer\ntofaces(FM::Vector{NgonFace{m, TF}} ) where m where TF <: Integer\n\nConverts input to GeometryBasics compliant faces with standard integer types. \n\nDescription\n\nThe tofaces function converts \"non-standard\" (for Comodo) face set  descriptions to \"standard\" ones. The following is considered such as standard:  Vector{GeometryBasics.NgonFace{N,T}} where N where T<:Integer  The input faces FM are converted to this format. FM can be of the following  types: \n\nFM::Vector{Vector{TF}} where TF<:Integer, whereby each Vector entry is \n\nconsidered a face\n\nFM::Matrix{TF} where TF<:Integer, whereby each row is considered a face\nVector{NgonFace{m, OffsetInteger{-1, TF}}} where TF<:Integer, whereby the \n\nspecial integer type OffsetInteger{-1, TF} is converted to Int.   If the intput is already of the right type this function leaves the input  unchanged.\n\n\n\n\n\n","category":"function"},{"location":"functions/#topoints","page":"Functions","title":"topoints","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.topoints","category":"page"},{"location":"functions/#Comodo.topoints","page":"Functions","title":"Comodo.topoints","text":"topoints(VM::Matrix{T}) where T<: Real\ntopoints(VM::Union{Array{Vec{N, T}, 1}, GeometryBasics.StructArray{TT,1} }) where TT <: AbstractPoint{N,T} where T <: Real where N   \ntopoints(VM::Vector{Vector{T}}) where T <: Real  \ntopoints(VM::Vector{Point{ND,TV}}) where ND where TV <: Real\n\nConverts input to GeometryBasics compliant simple points without meta content.\n\nDescription\n\nThe topoints function converts the \"non-standard\" (for Comodo) input points  defined by VM to the \"standard\" format: VM::Vector{Point{ND,TV}} where ND where TV <: Real. For matrix input each row is considered a point. For vector input each vector  entry is considered a point.     \n\n\n\n\n\n","category":"function"},{"location":"functions/#togeometrybasics_mesh","page":"Functions","title":"togeometrybasics_mesh","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.togeometrybasics_mesh","category":"page"},{"location":"functions/#Comodo.togeometrybasics_mesh","page":"Functions","title":"Comodo.togeometrybasics_mesh","text":"togeometrybasics_mesh\n\nConverts the input to a GeometryBasics.Mesh\n\nDescription\n\nThis function converts the input faces F and vertices V to a  GeometryBasics.Mesh. The function tofaces and topoints are used prior to  conversion, to ensure standard faces and point types are used. \n\n\n\n\n\n","category":"function"},{"location":"functions/#edgecrossproduct","page":"Functions","title":"edgecrossproduct","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.edgecrossproduct","category":"page"},{"location":"functions/#Comodo.edgecrossproduct","page":"Functions","title":"Comodo.edgecrossproduct","text":"edgecrossproduct(F,V::Vector{Point{ND,T}}) where ND where T<:Real\n\nReturns the edge cross product, useful for nomal direction and area computations. \n\n# Description\n\nThis function computes the so-called edge-cross-product for a input mesh that is either defined by the faces F and vertices V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#facenormal","page":"Functions","title":"facenormal","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.facenormal","category":"page"},{"location":"functions/#Comodo.facenormal","page":"Functions","title":"Comodo.facenormal","text":"facenormal(F,V)\n\nReturns the normal directions for each face.\n\nDescription\n\nThis function computes the per face normal directions for the input mesh defined  either by the faces F and vertices V or by the GeometryBasics mesh M. \n\n\n\n\n\n","category":"function"},{"location":"functions/#facearea","page":"Functions","title":"facearea","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.facearea","category":"page"},{"location":"functions/#Comodo.facearea","page":"Functions","title":"Comodo.facearea","text":"facearea(F,V)\n\nReturns the area for each face. \n\nDescription\n\nThis function computes the per face area for the input mesh defined either by  the faces F and vertices V or by the GeometryBasics mesh M. \n\n\n\n\n\n","category":"function"},{"location":"functions/#vertexnormal","page":"Functions","title":"vertexnormal","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.vertexnormal","category":"page"},{"location":"functions/#Comodo.vertexnormal","page":"Functions","title":"Comodo.vertexnormal","text":"vertexnormal(F,V; weighting=:area)\n\nReturns the surface normal at each vertex.\n\nDescription\n\nThis function computes the per vertex surface normal directions for the input  mesh defined either by the faces F and vertices V or by the GeometryBasics mesh M. The optional parameter weighting sets how the face normal directions  are averaged onto the vertices. If weighting=:none a plain average for the  surrounding faces is used. If instead weighting=:area (default), then the average is weighted based on the face areas. \n\n\n\n\n\n","category":"function"},{"location":"functions/#edgelengths","page":"Functions","title":"edgelengths","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.edgelengths","category":"page"},{"location":"functions/#Comodo.edgelengths","page":"Functions","title":"Comodo.edgelengths","text":"edgelengths(E::LineFace,V)\nedgelengths(F,V)\nedgelengths(M::GeometryBasics.Mesh)\n\nReturns edge lengths.\n\nDescription\n\nThis function computes the lengths of the edges defined by edge vector E (e.g as obtained from meshedges(F,V), where F is a face vector, and V is a  vector of vertices.  Alternatively the input mesh can be a GeometryBasics mesh M.\n\n\n\n\n\n","category":"function"},{"location":"functions/#subtri","page":"Functions","title":"subtri","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subtri","category":"page"},{"location":"functions/#Comodo.subtri","page":"Functions","title":"Comodo.subtri","text":"subtri(F,V,n; method = :linear)\nsubtri(F,V,n; method = :Loop)\n\nRefines triangulations through splitting.\n\nDescription\n\nThe subtri function refines triangulated meshes iteratively. For each iteration each original input triangle is split into 4 triangles to form the refined mesh  (one central one, and 3 at each corner). The following refinement methods are  implemented: \n\nmethod=:linear : This is the default method, and refines the triangles in a  simple linear manor through splitting. Each input edge simply obtains a new  mid-edge node. \n\nmethod=:Loop : This method features Loop-subdivision [1,2]. Rather than linearly  splitting edges and maintaining the original coordinates, as for the linear  method, this method computes the new points in a special weighted sense such  that the surface effectively approaches a \"quartic box spline\". Hence this  method both refines and smoothes the geometry through spline approximation. \n\nReferences\n\nCharles Loop, Smooth Subdivision Surfaces Based on Triangles, M.S. Mathematics Thesis, University of Utah. 1987.\nJos Stam, Charles Loop, Quad/Triangle Subdivision, doi: 10.1111/1467-8659.t01-2-00647\n\n\n\n\n\n","category":"function"},{"location":"functions/#subquad","page":"Functions","title":"subquad","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subquad","category":"page"},{"location":"functions/#Comodo.subquad","page":"Functions","title":"Comodo.subquad","text":"subquad(F::Vector{NgonFace{4,TF}},V::Vector{Point{ND,TV}},n::Int; method=:linear) where TF<:Integer where ND where TV <: Real subquad(F::Vector{NgonFace{4,TF}},V::Vector{Point{ND,TV}},n::Int; method=:Catmull_Clark) where TF<:Integer where ND where TV <: Real\n\nRefines quadrangulations through splitting.\n\nDescription\n\nThe subquad function refines quad meshes iteratively. For each iteration each original input quad is split into 4 smaller quads to form the refined mesh.  The following refinement methods are implemented: \n\nmethod=:linear : This is the default method, and refines the quads in a  simple linear manor through splitting. Each input edge simply obtains a new  mid-edge node, and each face obtains a new central node. \n\nmethod=:Catmull_Clark : This method features Catmull_Clark-subdivision [1].  Rather than linearly splitting edges and maintaining the original coordinates,  as for the linear method, this method computes the new points in a special  weighted sense such that the surface effectively approaches a bicubic B-spline  surface. Hence this method both refines and smoothes the geometry through  spline approximation. \n\nReferences\n\nE. Catmull and J. Clark, Recursively generated B-spline surfaces on arbitrary topological meshes, Computer-Aided Design, vol. 10, no. 6, pp. 350-355, Nov. 1978, doi: 10.1016/0010-4485(78)90110-0.\n\n\n\n\n\n","category":"function"},{"location":"functions/#geosphere","page":"Functions","title":"geosphere","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.geosphere","category":"page"},{"location":"functions/#Comodo.geosphere","page":"Functions","title":"Comodo.geosphere","text":"geosphere(n::Int,r::T; method=:linear) where T <: Real\n\nReturns a geodesic sphere triangulation\n\nDescription\n\nThis function returns a geodesic sphere triangulation based on the number of refinement iterations n and the radius r. Geodesic spheres (aka Buckminster-Fuller  spheres) are triangulations of a sphere that have near uniform edge lenghts.  The algorithm starts with a regular icosahedron. Next this icosahedron is refined  n times, while nodes are pushed to a sphere surface with radius r at each iteration. Two methods are available, i.e. :linear (default) and :Loop  (see also subtri). The former features simply linear splitting while the latter features the Loop method which may produce a smoother result.\n\n\n\n\n\n","category":"function"},{"location":"functions/#hexbox","page":"Functions","title":"hexbox","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.hexbox","category":"page"},{"location":"functions/#Comodo.hexbox","page":"Functions","title":"Comodo.hexbox","text":"hexbox(boxDim,boxEl)\n\nReturns a hexahedral mesh of a box\n\nDescription\n\nThis function returns a hexahedral mesh for a 3D rectangular box domain. \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_face_edge","page":"Functions","title":"con_face_edge","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_face_edge","category":"page"},{"location":"functions/#Comodo.con_face_edge","page":"Functions","title":"Comodo.con_face_edge","text":"con_face_edge(F,E_uni=nothing,indReverse=nothing)\n\nReturns the edges connected to each face.\n\nDescription\n\nThis function computes the face-edge connectivity. The input faces F (and  optionally also the unique edges E_uni and reverse indices indReverse to map to the non-unique edges, see also gunique) are used to create a list of edges  connected to each face. If F contains N faces then the output contains N such  lists. For triangles the output contains 3 edges per faces, for quads 4 per face and so on.   \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_edge_face","page":"Functions","title":"con_edge_face","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_edge_face","category":"page"},{"location":"functions/#Comodo.con_edge_face","page":"Functions","title":"Comodo.con_edge_face","text":"conedgeface(F,E_uni=nothing,indReverse=nothing)\n\nReturns the faces connected to each edge.\n\nDescription\n\nThis function computes the edge-face connectivity. The input faces F (and  optionally also the unique edges E_uni and reverse indices indReverse to map to the non-unique edges, see also gunique) are used to create a list of faces  connected to each edges. If E_uni contains N edges then the output contains  N such lists. For non-boundary edges each edge should connect to 2 faces.  Boundary edges connect to just 1 face.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_face_face","page":"Functions","title":"con_face_face","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_face_face","category":"page"},{"location":"functions/#Comodo.con_face_face","page":"Functions","title":"Comodo.con_face_face","text":"con_face_face(F,E_uni=nothing,indReverse=nothing,con_E2F=nothing,con_F2E=nothing)\n\nReturns the edge-connected faces for each face.\n\nDescription\n\nThis function computes the face-face connectivity for each face. The input faces F are used to create a list of faces connected to each face by a shared edge. For non-boundary triangles for instance the output contains 3 edges per faces  (which may be less for boundary triangles), and similarly non-boundary quads  would each have 4 edge-connected faces. Additional optional inputs include: the  unique edges E_uni, the reverse indices indReverse to map to the non-unique  edges (see also gunique), as well as the edge-face con_E2F and face-edge  con_F2E connectivity. These are all needed for computing the face-face  connectivity and supplying them if already computed therefore save time.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_face_face_v","page":"Functions","title":"con_face_face_v","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_face_face_v","category":"page"},{"location":"functions/#Comodo.con_face_face_v","page":"Functions","title":"Comodo.con_face_face_v","text":"con_face_face_v(F,V=nothing,con_V2F=nothing)\n\nReturns the vertex-connected faces for each face.\n\nDescription\n\nThis function computes the face-face connectivity for each face. The input faces F are used to create a list of faces connected to each face by a shared vertex. Additional optional inputs include: the vertices V, and the vertex-face  connectivity con_V2F. In terms of vertices only the number of vertices, i.e.  length(V) is neede, if V is not provided it is assumed that length(V)  corresponds to the largest index in F. The vertex-face connectivity if not supplied, will be computed by this function, hence computational time may be saved  if it was already computed. \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_vertex_simplex","page":"Functions","title":"con_vertex_simplex","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_vertex_simplex","category":"page"},{"location":"functions/#Comodo.con_vertex_simplex","page":"Functions","title":"Comodo.con_vertex_simplex","text":"con_vertex_simplex(F,V=nothing)\n\nReturns how vertices connect to simplices\n\nDescription\n\nThis function computes the vertex-simplex connectivity for each vertex. The input simplices F are used to create a list of simplices connected to each vertex. Additional optional inputs include: the vertices V. In terms of vertices only the number of vertices, i.e. length(V) is needed,  if V is not provided it is assumed that length(V) corresponds to the largest index in F.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_vertex_face","page":"Functions","title":"con_vertex_face","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_vertex_face","category":"page"},{"location":"functions/#Comodo.con_vertex_face","page":"Functions","title":"Comodo.con_vertex_face","text":"con_vertex_face(F,V=nothing)\n\nReturns how vertices connect to faces\n\nDescription\n\nThis function is an alias of con_vertex_simplex, and computes the vertex-face  connectivity for each vertex. The input faces F are used to create a list of  faces connected to each vertex. Additional optional inputs include: the vertices V. In terms of vertices only the number of vertices, i.e. length(V) is needed,  if V is not provided it is assumed that length(V) corresponds to the largest index in F.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_vertex_edge","page":"Functions","title":"con_vertex_edge","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_vertex_edge","category":"page"},{"location":"functions/#Comodo.con_vertex_edge","page":"Functions","title":"Comodo.con_vertex_edge","text":"con_vertex_edge(F,V=nothing)\n\nReturns how vertices connect to edges\n\nDescription\n\nThis function is an alias of con_vertex_simplex, and computes the vertex-edge  connectivity for each vertex. The input edges E are used to create a list of  edges connected to each vertex. Additional optional inputs include: the vertices V. In terms of vertices only the number of vertices, i.e. length(V) is needed,  if V is not provided it is assumed that length(V) corresponds to the largest index in E.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_edge_edge","page":"Functions","title":"con_edge_edge","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_edge_edge","category":"page"},{"location":"functions/#Comodo.con_edge_edge","page":"Functions","title":"Comodo.con_edge_edge","text":"con_edge_edge(E_uni,con_V2E=nothing)\n\nReturns the vertex-connected edges for each edge.\n\nDescription\n\nThis function computes the edge-edge connectivity for each edge. The input edges F are used to create a list of edges connected to each edge by a shared vertex. Additional optional inputs include: con_V2E (the vertex-edge connectivity), which is instead computed when not provided.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_vertex_vertex_f","page":"Functions","title":"con_vertex_vertex_f","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_vertex_vertex_f","category":"page"},{"location":"functions/#Comodo.con_vertex_vertex_f","page":"Functions","title":"Comodo.con_vertex_vertex_f","text":"con_vertex_vertex_f(F,V=nothing,con_V2F=nothing)\n\nReturns the face-connected vertices for each vertex.\n\nDescription\n\nThis function computes the vertex-vertex connectivity for each vertex using the  vertex connected faces. The input faces F are used to create a list of vertices connected to each vertex by a shared face. Additional optional inputs include:  the vertices V and con_V2F (the vertex-face connectivity). In terms of vertices only the number of vertices, i.e. length(V) is needed, if V is not provided  it is assumed that length(V) corresponds to the largest index in F. The  vertex-face connectivity con_V2F is needed, hence is computed when not provided.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#con_vertex_vertex","page":"Functions","title":"con_vertex_vertex","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.con_vertex_vertex","category":"page"},{"location":"functions/#Comodo.con_vertex_vertex","page":"Functions","title":"Comodo.con_vertex_vertex","text":"con_vertex_vertex(E,V=nothing,con_V2E=nothing)\n\nReturns the edge-connected vertices for each vertex.\n\nDescription\n\nThis function computes the vertex-vertex connectivity for each vertex using the  vertex connected edges. The input edges E are used to create a list of vertices connected to each vertex by a shared edge. Additional optional inputs include:  the vertices V and con_V2E (the vertex-edge connectivity). In terms of vertices only the number of vertices, i.e. length(V) is needed, if V is not provided  it is assumed that length(V) corresponds to the largest index in E. The  vertex-edge connectivity con_V2E is needed, hence is computed when not provided.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#meshconnectivity","page":"Functions","title":"meshconnectivity","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.meshconnectivity","category":"page"},{"location":"functions/#Comodo.meshconnectivity","page":"Functions","title":"Comodo.meshconnectivity","text":"meshconnectivity(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}) where N where TF<:Integer where ND where TV<:Real\n\nReturns all mesh connectivity data\n\nDescription\n\nThis function returns the ConnectivitySet, i.e. all mesh connectivity data for  the input mesh defined by the faces F and the vertices V.  The ConnectivitySet contains the following connectivity descriptions: \n\nface-edge\nedge-face\nface-face\nface-face (wrt vertices)\nvertex-face\nvertex-edge\nedge-edge\nvertex-vertex\nvertex-vertex (wrt faces)\n\n\n\n\n\n","category":"function"},{"location":"functions/#mergevertices","page":"Functions","title":"mergevertices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.mergevertices","category":"page"},{"location":"functions/#Comodo.mergevertices","page":"Functions","title":"Comodo.mergevertices","text":"mergevertices(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}; roundVertices = true, numDigitsMerge=nothing) where N where TF<:Integer where ND where TV<:Real\n\nMerges points that coincide\n\nDescription\n\nThis function take the faces F and vertices V and merges points that are sufficiently  similar. Once points are merged the indices in F are corrected for the new reduced point set. \n\n\n\n\n\n","category":"function"},{"location":"functions/#smoothmesh_laplacian","page":"Functions","title":"smoothmesh_laplacian","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.smoothmesh_laplacian","category":"page"},{"location":"functions/#Comodo.smoothmesh_laplacian","page":"Functions","title":"Comodo.smoothmesh_laplacian","text":"smoothmesh_laplacian(F,V,con_V2V=nothing; n=1, λ=0.5)\n\nDescription\n\nThis function implements weighted Laplacian mesh smoothing. At each  iteration, this method replaces each point by an updated coordinate based on the  mean coordinates of that point's Laplacian umbrella. The update features a lerp like weighting between the previous iterations coordinates and the mean  coordinates. The code features Vs[q] = (1.0-λ).*Vs[q] .+ λ*mean(V[con_V2V[q]]) As can be seen, the weighting is controlled by the input parameter λ which is in the range (0,1). If λ=0 then no smoothing occurs. If λ=1 then pure  Laplacian mean based smoothing occurs. For intermediate values a linear blending between the two occurs.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#smoothmesh_hc","page":"Functions","title":"smoothmesh_hc","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.smoothmesh_hc","category":"page"},{"location":"functions/#Comodo.smoothmesh_hc","page":"Functions","title":"Comodo.smoothmesh_hc","text":"smoothmesh_hc(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}, n=1, α=0.1, β=0.5; con_V2V=nothing, tolDist=nothing, constrained_points=nothing) where N where TF<:Integer where ND where TV<:Real\n\nDescription\n\nThis function implements HC (Humphrey's Classes) smoothing [1]. This method uses Laplacian like smoothing but aims to compensate for shrinkage/swelling by also  \"pushing back\" towards the original coordinates. \n\nReferences\n\nVollmer et al., Improved Laplacian Smoothing of Noisy Surface Meshes, 1999. doi: 10.1111/1467-8659.00334\n\n\n\n\n\n","category":"function"},{"location":"functions/#quadplate","page":"Functions","title":"quadplate","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.quadplate","category":"page"},{"location":"functions/#Comodo.quadplate","page":"Functions","title":"Comodo.quadplate","text":"quadplate(plateDim,plateElem; orientation=:up)\n\nReturns a quad mesh for a plate\n\nDescription\n\nThis function creates a quadrilateral mesh (faces F and vertices V) for a  plate. The dimensions in the x-, and y-direction are specified in the input vector  plateDim, and the number of elements to use in each direction in the input  vector plateElem. \n\n\n\n\n\n","category":"function"},{"location":"functions/#quadsphere","page":"Functions","title":"quadsphere","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.quadsphere","category":"page"},{"location":"functions/#Comodo.quadsphere","page":"Functions","title":"Comodo.quadsphere","text":"quadsphere(n::Int,r::T) where T <: Real\n\nReturns a quadrangulated sphere\n\nDescription\n\nThis function creates a quadrilateral mesh (faces F and vertices V) for a sphere with a radius defined by the input r. The input n defines the density of sphere mesh. The quad mesh is constructed using subquad subdivision of a regular cube,  whereby n sets the number of splitting iterations to use. Using n=0 therefore returns a cube.\n\n\n\n\n\n","category":"function"},{"location":"functions/#loflinear","page":"Functions","title":"loflinear","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.loftlinear","category":"page"},{"location":"functions/#Comodo.loftlinear","page":"Functions","title":"Comodo.loftlinear","text":"loftlinear(V1,V2;num_steps=2,close_loop=true,face_type=:tri)\n\nLofts surface between curves\n\nDescription\n\nThe loftlinear function spans a surface from input curve V1 to curve V2.  The surface is formed by \"lerping\" curves from V1 to V2 in num_steps  steps, and forming mesh faces between each curve. If close_loop==true then it is assumed the curves (and therefore the output surface mesh should be  closed over, i.e. that a connection should be made between each curve end and  start point. The user can request different face types for the output. The  default is face_type=:tri which will form isoceles triangles (or equilateral  triangles if the spacing is even) for a planar curve. The other face_type options supported are :quad (quadrilateral), and :tri_slash. For the  latter, triangles are formed by slashing the quads.  \n\nArguments:\n\nV1::Vector: n-vector \nV2::Vector: n-vector\n\n\n\n\n\n","category":"function"},{"location":"functions/#pointspacingmean","page":"Functions","title":"pointspacingmean","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.pointspacingmean","category":"page"},{"location":"functions/#Comodo.pointspacingmean","page":"Functions","title":"Comodo.pointspacingmean","text":"pointspacingmean(V::Vector{Point3{Float64}})\npointspacingmean(F::Array{NgonFace{N, Int}, 1},V::Vector{Point3{Float64}}) where N\n\nThe pointspacingmean function computes the mean spacing between points. The  input can be just the coordinate set V, a vector of Point3  points, or also a set of edges E or faces F. If only V is provided it is  assumed that V represents an ordered set of \"adjacent\" points, e.g. as for a  curve. If a vector of edges E or a vector of faces F is also provided, then  the average edge length is computed. If instead a set of facesF` is provided  then edges are first computed after which the mean edge spacing is return. \n\n\n\n\n\n","category":"function"},{"location":"functions/#ray_triangle_intersect","page":"Functions","title":"ray_triangle_intersect","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ray_triangle_intersect","category":"page"},{"location":"functions/#Comodo.ray_triangle_intersect","page":"Functions","title":"Comodo.ray_triangle_intersect","text":"ray_triangle_intersect(F::Vector{TriangleFace{Int}},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))\nray_triangle_intersect(f::TriangleFace{Int},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))\n\nDescription\n\nThis function can compute triangle-ray or triangle-line intersections through  the use of the \"Möller-Trumbore triangle-ray intersection algorithm\" [1]. The  required inputs are as follows: \n\nF an single face or a vector of faces, e.g. Vector{TriangleFace{Int}} V The triangle vertices as a vector of points, i.e. Vector{Point{3, Float64}} ray_vector The ray vector which can be Vector{Point{3, Float64}} or Vec3{Float64}\n\nThe following optional input parameters can be provided:  rayType = :ray (default) or :line. This defines wether the vector is treated as a ray (extends indefinately) or as a line (finite length) triSide = 1 (default) or 0 or -1.  When triSide=1 only the inward intersections are considered, e.g. when the ray or line enters the shape (ray/line is pointing against face normal) When triSide=-1 only the outward intersections are considered, e.g. when the ray or line exits the shape (ray/line is pointing allong face normal) When triSide=0 both inward and outward intersections are considered. tolEps = eps(Float64) (default) \n\nReferences\n\nMöller, Tomas; Trumbore, Ben (1997). Fast, Minimum Storage Ray-Triangle Intersection. Journal of Graphics Tools. 2: 21-28. doi: 10.1080/10867651.1997.10487468.\n\n\n\n\n\n","category":"function"},{"location":"functions/#mesh_curvature_polynomial","page":"Functions","title":"mesh_curvature_polynomial","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.mesh_curvature_polynomial","category":"page"},{"location":"functions/#Comodo.mesh_curvature_polynomial","page":"Functions","title":"Comodo.mesh_curvature_polynomial","text":"mesh_curvature_polynomial(F::Vector{TriangleFace{Int}},V::Vector{Point3{Float64}})\nmesh_curvature_polynomial(M::GeometryBasics.Mesh)\n\nDescription\n\nThis function computes the mesh curvature at each vertex for the input mesh  defined by the face F and the vertices V. A local polynomial is fitted to  each point's \"Laplacian umbrella\" (point neighbourhood), and the curvature of  this fitted form is derived. Instead of the mesh faces and vertices one may  instead specify the GeometryBasics.Mesh M as the input. \n\nThe reference below [1] provides more detail on the algorithm. In addition, this  implementation was created with the help of this helpful document,  which features a nice overview of the theory/steps involved in this algorithm. \n\nReferences\n\nF. Cazals and M. Pouget, Estimating differential quantities using polynomial fitting of osculating jets, Computer Aided Geometric Design, vol. 22, no. 2, pp. 121-146, Feb. 2005, doi: 10.1016/j.cagd.2004.09.004\n\n\n\n\n\n","category":"function"},{"location":"functions/#separate_vertices","page":"Functions","title":"separate_vertices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.separate_vertices","category":"page"},{"location":"functions/#Comodo.separate_vertices","page":"Functions","title":"Comodo.separate_vertices","text":"separate_vertices(F::Array{NgonFace{N, Int}, 1},V::Array{Point{M, T}, 1}) where N where M where T<:Real\nseparate_vertices(M::GeometryBasics.Mesh)\n\nThis function takes the input mesh defined by the faces F and vertices V and separates any shared vertices. It does this by giving each face its own set of  unshared vertices. Note that any unused points are not returned in the output  point array Vn. Indices for the mapping are not created here but can simply be obtained using reduce(vcat,F).\n\n\n\n\n\n","category":"function"},{"location":"functions/#evenly_sample","page":"Functions","title":"evenly_sample","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.evenly_sample","category":"page"},{"location":"functions/#Comodo.evenly_sample","page":"Functions","title":"Comodo.evenly_sample","text":"evenly_sample(V::Vector{Point{ND,TV}}, n::Int; rtol = 1e-8, niter = 1) where ND where TV<:Real\n\nEvenly samples curves. \n\nDescription\n\nThis function aims to evenly resample the input curve defined by the ND points  V using n points. The function returns the resampled points as well as the  spline interpolator S used. The output points can also be retriebed by using:  S.(range(0.0, 1.0, n)).  Note that the even sampling is defined in terms of the curve length for a 4th  order natural B-spline that interpolates the input data. Hence if significant  curvature exists for the B-spline between two adjacent data points then the  spacing between points in the output may be non-uniform (despite the allong  B-spline distance being uniform). \n\n\n\n\n\n","category":"function"},{"location":"functions/#invert_faces","page":"Functions","title":"invert_faces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.invert_faces","category":"page"},{"location":"functions/#Comodo.invert_faces","page":"Functions","title":"Comodo.invert_faces","text":"invert_faces(F::Vector{NgonFace{N, TF}, 1}) where N where TF<:Integer\n\nFlips face orientations.\n\nDescription\n\nThis function inverts the faces in F, such that the face normal will be  flipped, by reversing the node order for each face. \n\n\n\n\n\n","category":"function"},{"location":"functions/#kabsch_rot","page":"Functions","title":"kabsch_rot","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.kabsch_rot","category":"page"},{"location":"functions/#Comodo.kabsch_rot","page":"Functions","title":"Comodo.kabsch_rot","text":"R = kabsch_rot(V1::Array{Point{N, T}, 1},V2::Array{Point{N, TT}, 1}) where N where T<:Real where TT<:Real\n\nDescription\n\nComputes the rotation tensor R to rotate the points in V1 to best match the  points in V2. \n\nReference\n\nWolfgang Kabsch, A solution for the best rotation to relate two sets of vectors, Acta Crystallographica Section A, vol. 32, no. 5, pp. 922-923, 1976, doi: 10.1107/S0567739476001873  https://en.wikipedia.org/wiki/Kabsch_algorithm \n\n\n\n\n\n","category":"function"},{"location":"functions/#sweeploft","page":"Functions","title":"sweeploft","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.sweeploft","category":"page"},{"location":"functions/#Comodo.sweeploft","page":"Functions","title":"Comodo.sweeploft","text":"F,V = sweeploft(Vc,V1,V2; face_type=:quad, num_twist = 0, close_loop=true)\n\nDescription\n\nThis function implements swept lofting. The start curve V1 is pulled allong the  guide curve Vc while also gradually (linearly) morphing into the end curve  V2.  The optional parameter face_type (default :quad) defines the type of mesh  faces uses. The same face types as loftlinear and extrudecurve are supported,  i.e. :quad, :tri_slash, tri, or quad2tri.  The optional parameter num_twist (default is 0) can be used to add an integer  number (negative or positive) of full twists to the loft.  Finally the optional parameter close_loop (default is true) determines if the section curves are deemed closed or open ended. \n\n\n\n\n\n","category":"function"},{"location":"functions/#revolvecurve","page":"Functions","title":"revolvecurve","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.revolvecurve","category":"page"},{"location":"functions/#Comodo.revolvecurve","page":"Functions","title":"Comodo.revolvecurve","text":"revolvecurve(Vc::Vector{Point{ND,TV}}; extent = 2.0*pi, direction=:positive, n=Vec{3, Float64}(0.0,0.0,1.0),num_steps=nothing,close_loop=true,face_type=:quad)  where ND where TV<:Real\n\nRevolves curves to build surfaces \n\nDescription\n\nThis function rotates the curve Vc by the angle extent, in the direction  defined by direction (:positive, :negative, :both), around the vector  n, to build the output mesh defined by the faces F and vertices V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#batman","page":"Functions","title":"batman","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.batman","category":"page"},{"location":"functions/#Comodo.batman","page":"Functions","title":"Comodo.batman","text":"batman(n::Int)\n\nDescription\n\nThe batman function creates points on the curve for the Batman logo. The curve is useful for testing surface meshing algorithms since it contains sharp  transitions and pointy features. The user requests n points on the curve. The default forces exactly n points which may result in an assymetric curve. To  instead force symmetry the user can set the optional parameter symmetric=true.  In this case the output will be symmetric allong the y-axis, however the number of points on the curve may have increased (if the input n is not even). The second optional input is the direction of the curve, i.e. if it is clockwise,  dir=:cw or anti-clockwise dir=:acw.  The implementation is based on a \"parameterised Batman equation\" 1. The following modifications where made, the curve is here centered around  [0,0,0], scaled to be 2 in width, resampled evenly, and the default curve  direction is anti-clockwise. \n\nReferences\n\nhttps://www.desmos.com/calculator/ajnzwedvql\n\n\n\n\n\n","category":"function"},{"location":"functions/#tridisc","page":"Functions","title":"tridisc","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tridisc","category":"page"},{"location":"functions/#Comodo.tridisc","page":"Functions","title":"Comodo.tridisc","text":"tridisc(r=1.0,n=0; ngon=6, method = :linear, orientation=:up)\n\nDescription\n\nGenerates the faces F and vertices V for a triangulated disc (circle). The  algorithm starts with a triangulated hexagon (obtained if n=0) and uses  iterative subtriangulation, and uses iterative subdivision (and pushing of  boundary points to circular boundary) to obtain the final mesh. The subdivision method is an optional input, and is either :Loop (default) or :linear.  Lastly the optional input orientation, which can be :up or :down sets the  face normal direction. \n\n\n\n\n\n","category":"function"},{"location":"functions/#regiontrimesh","page":"Functions","title":"regiontrimesh","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.regiontrimesh","category":"page"},{"location":"functions/#Comodo.regiontrimesh","page":"Functions","title":"Comodo.regiontrimesh","text":"regiontrimesh(VT,R,P)\n\nDescription\n\nGenerates a multi-region triangle mesh for the input regions. The boundary  curves for all regions are containedin the tuple VT. Each region to be meshed is next defined using a tuple R containing indices into the curve typle VT.  If an entry in R contains only one index then the entire curve domain is  meshed. If R contains multiple indices then the first index is assumed to be  for the outer boundary curve, while all subsequent indices are for boundaries  defining holes in this region. \n\n\n\n\n\n","category":"function"},{"location":"functions/#scalesimplex","page":"Functions","title":"scalesimplex","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.scalesimplex","category":"page"},{"location":"functions/#Comodo.scalesimplex","page":"Functions","title":"Comodo.scalesimplex","text":"scalesimplex(F,V,s)\n\nScales faces (or general simplices) wrt their centre. \n\nDescription\n\nThis function scales each simplex (e.g. a face) wrt their centre (mean of  coordinates). This function is useful in generating lattice structures from  elements as well as to create visualisations whereby \"looking into\" the mesh is needed. \n\n\n\n\n\n","category":"function"},{"location":"functions/#subcurve","page":"Functions","title":"subcurve","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subcurve","category":"page"},{"location":"functions/#Comodo.subcurve","page":"Functions","title":"Comodo.subcurve","text":"subcurve(V,n)\n\nAdds n points between each curve point.  \n\nDescription\n\nThis function adds n points between each current point on the curve V.\n\n\n\n\n\n","category":"function"},{"location":"functions/#dualclad","page":"Functions","title":"dualclad","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.dualclad","category":"page"},{"location":"functions/#Comodo.dualclad","page":"Functions","title":"Comodo.dualclad","text":"dualclad(F::Vector{NgonFace{N, TF}},V::Vector{Point{ND,TV}},s::T; connectivity=:face) where N where TF<:Integer where ND where TV<:Real where T<:Real\n\nReturns a surface conforming dual lattice\n\nDescription\n\n\n\n\n\n","category":"function"},{"location":"functions/#tet2hex","page":"Functions","title":"tet2hex","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tet2hex","category":"page"},{"location":"functions/#Comodo.tet2hex","page":"Functions","title":"Comodo.tet2hex","text":"tet2hex(E::Vector{Tet4{T}},V::Vector{Point{ND,TV}}) where T<:Integer where ND where TV<:Real\n\nConverts tetrahedra to hexahedra\n\nDescription\n\nThis function converts the input tetrahedra defined by the element set E and the  vertex set V to a set of hexahedral elements Eh with vertices Vh. The conversion involves a splitting of each tetrahedron into 4 hexahedra. \n\n\n\n\n\n","category":"function"},{"location":"functions/#element2faces","page":"Functions","title":"element2faces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.element2faces","category":"page"},{"location":"functions/#Comodo.element2faces","page":"Functions","title":"Comodo.element2faces","text":"element2faces(E::Vector{Element{N,T}}) where N where T\n\nReturns element faces\n\nDescription\n\nThis function computes the faces for the input elements defined by E. The elements should be Vectors consisting of Tet4, Hex8 elements. \n\n\n\n\n\n","category":"function"},{"location":"functions/#subhex","page":"Functions","title":"subhex","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subhex","category":"page"},{"location":"functions/#Comodo.subhex","page":"Functions","title":"Comodo.subhex","text":"subhex(E::Vector{Hex8{T}},V::Vector{Point{ND,TV}},n::Int; direction=0) where T<:Integer where ND where TV<:Real\n\nSplit hexahedral elements\n\nDescription\n\nThis function splits the hexahedral elements defined by the elements E and  vertices V. Splitting is done n times as requested. By default the splitting  occurs in all direction (corresponding to the default direction=0). If instead direction is set to 1, 2, or 3, then the splitting only occur in the first, second or third local element direction respectively. Note that this direction depends  on node order used. For a hexahedron where by nodes 1:4 are for the bottom, and  nodes 5:8 are for the top of the element then the directions 1, 2, and 3 correspond  to the x-, y-, and z-direction respectively.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#rhombicdodecahedron","page":"Functions","title":"rhombicdodecahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.rhombicdodecahedron","category":"page"},{"location":"functions/#Comodo.rhombicdodecahedron","page":"Functions","title":"Comodo.rhombicdodecahedron","text":"rhombicdodecahedron(r = 1.0)\n\nCreates mesh for rhombicdodecahedron\n\nDescription\n\nThis function creates the faces F and vertices V for a rhombicdodecahedron.  The size of the shape is set by the width w in the xy-plane. \n\n\n\n\n\n","category":"function"},{"location":"functions/#tri2quad","page":"Functions","title":"tri2quad","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tri2quad","category":"page"},{"location":"functions/#Comodo.tri2quad","page":"Functions","title":"Comodo.tri2quad","text":"tri2quad(F,V; method=:split)\n\nConverts triangles to quads\n\nDescription\n\nThis function converts the input triangular mesh, defined by the faces F and  vertices V, to a quadrangulation. The method for this conversion is set using the attribute method which can be set to :split, splitting each triangle  into 3 quads by introducing a new central node, or :rhombic. whereby each  triangle edge is used to construct a rhombic quadrilateral face. \n\n\n\n\n\n","category":"function"},{"location":"functions/#tetgenmesh","page":"Functions","title":"tetgenmesh","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tetgenmesh","category":"page"},{"location":"functions/#Comodo.tetgenmesh","page":"Functions","title":"Comodo.tetgenmesh","text":"tetgenmesh(F::Array{NgonFace{N,TF}, 1},V::Vector{Point{3,TV}}; facetmarkerlist=nothing, V_regions=nothing,region_vol=nothing,V_holes=nothing,stringOpt=\"paAqYQ\")  where N where TF<:Integer where TV<:Real\n\nCreates a tetrahedral mesh\n\nDescription\n\nThis function uses the TetGen.jl library to mesh the input geometry defined by  the faces F and the vertices V using tetrahedral elements. Several optional input parameters are available: \n\nfacetmarkerlist, a vector of integers with the same length as F and defines a face label for each face. \nV_regions, a vector of points inside regions which require tetrahedral meshing.\nregion_vol, a vector of scalar values to denote the desired tetrahedral volume for each region.  \nV_holes, a vector of points inside holes (voids) that should remain empty. \nstringOpt, the TetGen command string to use. See also the TetGen documentation. \n\n\n\n\n\n","category":"function"},{"location":"functions/#surfacevolume","page":"Functions","title":"surfacevolume","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.surfacevolume","category":"page"},{"location":"functions/#Comodo.surfacevolume","page":"Functions","title":"Comodo.surfacevolume","text":"surfacevolume(F::Vector{NgonFace{N,TF}},V::Vector{Point{ND,TV}}) where N where TF<:Integer where ND where TV<:Real\n\nComputes closed surface volume\n\nDescription\n\nThis function computes the volume of a closed surface defined by the faces F  and the vertices V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#tetvolume","page":"Functions","title":"tetvolume","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tetvolume","category":"page"},{"location":"functions/#Comodo.tetvolume","page":"Functions","title":"Comodo.tetvolume","text":"tetvolume(E::Vector{Tet4{T}},V::Vector{Point{ND,TV}}) where T<:Integer where ND where TV<:Real\n\nComputes tetrahedral volumes\n\nDescription\n\nThis function computes the volume for each tetrahedron defined by the input E,  a vector of Tet4 elements, and V the point coordinates. \n\n\n\n\n\n","category":"function"},{"location":"functions/#extrudefaces","page":"Functions","title":"extrudefaces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.extrudefaces","category":"page"},{"location":"functions/#Comodo.extrudefaces","page":"Functions","title":"Comodo.extrudefaces","text":"extrudefaces(F::Vector{NgonFace{NF,TF}},V::Vector{Point{ND,TV}}; extent=1.0, direction=:positive, num_steps=2, N::Union{Vector{Point{ND,TN}},Vector{Vec{ND, TN}},Nothing}=nothing) where NF where TF<:Integer where ND where TV<:Real where TN<:Real\n\nExtrudes/thickens faces to form elements\n\nDescription\n\nThe inputs surface mesh, defined by the faces F and vertices V is extruded to create volumetric elements. Quadrilateral and triangular input faces are supported.  These extrude into hexahedral and pentahedral elements respectively.  The following input parameters are defined: \n\nextent<:Real (default = 1.0) the length of the extrusion   \ndirection is a symbol that is either :positive (default), :negative, or :both. \nN The extrusion vectors. The default is nothing in which case the local \n\nvertex normals are used. \n\nnum_steps (default is 2) is the number of nodes in the extrude direction, the \n\nnumber of elements in the extrude direction is therefore num_steps-1. \n\n\n\n\n\n","category":"function"},{"location":"functions/#filletcurve","page":"Functions","title":"filletcurve","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.filletcurve","category":"page"},{"location":"functions/#Comodo.filletcurve","page":"Functions","title":"Comodo.filletcurve","text":"filletcurve(V::Vector{Point{NV,TV}}; rMax::Union{Vector{T},T,Nothing}=nothing, constrain_method = :max, n=25, close_loop = false, eps_level = 1e-6) where TV<:Real where NV where T<:Real\n\nFillets/rounds curves\n\nDescription\n\nThe function takes in a curve defined by the points V and applies filleting (or rounding) to each \"corner\" (i.e. a point between two neighbouring points).  The maximum radius rMax is used as the largest possible radius to use. If this,  radius is not possible (e.g. if input points are too close), then a lower Radius is used. \n\n\n\n\n\n","category":"function"},{"location":"functions/#squircle","page":"Functions","title":"squircle","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.squircle","category":"page"},{"location":"functions/#Comodo.squircle","page":"Functions","title":"Comodo.squircle","text":"squircle(r::T,n::Int,τ=0.5; atol=1e-6, dir=:acw) where T <: Real\n\nCreates the squircle curve\n\nDescription\n\nThis function returns n points on a squircle. The squircle curve is defined  using the radius r, and the parameter τ. The latter controls the morphing  between a circle (τ=0) and square (τ=1).\n\n\n\n\n\n","category":"function"},{"location":"functions/#circlerange","page":"Functions","title":"circlerange","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.circlerange","category":"page"},{"location":"functions/#Comodo.circlerange","page":"Functions","title":"Comodo.circlerange","text":"circlerange(n::Int; dir=:acw, deg=false)\n\nCreates circular angles\n\nDescription\n\nThis function returns n angles for an even circular distribution of points.  The optional input dir can be set to :acw (default) resulting in an  anti-clockwise set of angles, and can be set to :cw for a clockwise set of  angles. Angles are returned in radians since deg is false by default.  Using deg=true results in angles in degrees. \n\n\n\n\n\n","category":"function"},{"location":"functions/#edgefaceangles","page":"Functions","title":"edgefaceangles","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.edgefaceangles","category":"page"},{"location":"functions/#Comodo.edgefaceangles","page":"Functions","title":"Comodo.edgefaceangles","text":"edgefaceangles(F::Vector{NgonFace{NF,TF}},V::Vector{Point{ND,TV}}; deg=false) where NF where TF<:Integer where ND where TV<:Real\n\nComputed angles between faces\n\nDescription\n\nThis function computes the angle between two faces for each unique edge in the  mesh specified by F and the vertices V. If the input mesh consists of n  unique edges then the output features n angles. For boundary edges, where no pair of faces exists, the angle returned is NaN. The default behaviour results in angles being computed in radians. However by specifying deg=true the user can request degrees instead. Finally two additional outputs are created, namely the unique edge vector E_uni as well as the edge-to-face connectivity vector ,con_E2F. \n\n\n\n\n\n","category":"function"},{"location":"functions/#faceanglesegment","page":"Functions","title":"faceanglesegment","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.faceanglesegment","category":"page"},{"location":"functions/#Comodo.faceanglesegment","page":"Functions","title":"Comodo.faceanglesegment","text":"faceanglesegment(F::Vector{NgonFace{NF,TF}},V::Vector{Point{ND,TV; deg=false, angleThreshold = pi/8, indStart = 1)  where NF where TF<:Integer where ND where TV<:Real\n\nSegments surfaces using face angles\n\nDescription\n\nThis function takes in a surface mesh defined by the faces F and the vertices  V, and segments the surface mesh based on face angles. The output consists of  a \"feature label\" vector G (a Vector{Int}, with the same length of F)  whereby adjacent faces whosee angle is smaller or equal to the angleThreshold  (default is pi/8) receive the same label. Hence this function allows one to find  all faces with a similar orientation, for instance all top or side faces of some  mesh. The function uses radians by default. However, buy specifying the optional  parameter deg=true the user request that angles and the angleThreshold are in degrees.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#eulerchar","page":"Functions","title":"eulerchar","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.eulerchar","category":"page"},{"location":"functions/#Comodo.eulerchar","page":"Functions","title":"Comodo.eulerchar","text":"eulerchar(F,V=nothing; E=nothing)\n\nComputes the Euler characteristic\n\nDescription\n\nThis function computes the Euler characteristic for the input surface defined by  the faces F and vertices V. The edges E are on optional input.  The Euler characteristic is defined as:  X = nV-nE-nF , where nV, nE, and nF define the number of surface vertices, edges, and  faces respectively. It is assumed all inputs are set of unique entities, e.g.  no vertices, edges, or faces occur multiple times. \n\n\n\n\n\n","category":"function"},{"location":"functions/#rhombicdodecahedronfoam","page":"Functions","title":"rhombicdodecahedronfoam","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.rhombicdodecahedronfoam","category":"page"},{"location":"functions/#Comodo.rhombicdodecahedronfoam","page":"Functions","title":"Comodo.rhombicdodecahedronfoam","text":"rhombicdodecahedronfoam(w::T,n::Union{Tuple{Vararg{Int, 3}}, Array{Int, 3}}; merge = true, orientation = :allign) where T<:Real\n\nCreates a rhombicdodecahedron foam\n\nDescription\n\nThis function creates a rhombicdodecahedron foam structure with a desired number of cells in each direction. The input is the cell width w and a 1-by-3 tuple  n defining the number of cells in each direction. The output consists of the  set of rhombic dodecahedron elements E and their vertex coordinates V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#truncatedoctahedron","page":"Functions","title":"truncatedoctahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.truncatedoctahedron","category":"page"},{"location":"functions/#Comodo.truncatedoctahedron","page":"Functions","title":"Comodo.truncatedoctahedron","text":"truncatedoctahedron(w=1.0)\n\nCreates a truncated octahedron\n\nDescription\n\nThis function creates a truncated octahedron. The input cell width w is used  to define the cell faces F and vertices V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#kelvinfoam","page":"Functions","title":"kelvinfoam","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.kelvinfoam","category":"page"},{"location":"functions/#Comodo.kelvinfoam","page":"Functions","title":"Comodo.kelvinfoam","text":"kelvinfoam(w::T,n::Union{Tuple{Vararg{Int, 3}}, Array{Int, 3}}; merge = true) where T<:Real\n\nCreates a Kelvin foam\n\nDescription\n\nThis function creates a Kelvin foam structure with a desired number of cells in each direction. The input is the cell width w and a 1-by-3 tuple n defining the number of cells in each direction. The output consists of the set of  truncated octahedron elements E and their vertex coordinates V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#minp","page":"Functions","title":"minp","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.minp","category":"page"},{"location":"functions/#Comodo.minp","page":"Functions","title":"Comodo.minp","text":"minp(V::Vector{Point{N,T}}) where N where T <:Real\n\nReturns minimum coordinates\n\nDescription\n\nThis function computes the minimum coordinates for all points. Points can be  N-dimensional and the output is another point of the same dimensionality but  with the lowest coordinate value for each direction. \n\n\n\n\n\n","category":"function"},{"location":"functions/#maxp","page":"Functions","title":"maxp","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.maxp","category":"page"},{"location":"functions/#Comodo.maxp","page":"Functions","title":"Comodo.maxp","text":"maxp(V::Vector{Point{N,T}}) where N where T <:Real\n\nReturns maximum coordinates\n\nDescription\n\nThis function computes the maximum coordinates for all points. Points can be  N-dimensional and the output is another point of the same dimensionality but  with the highest coordinate value for each direction. \n\n\n\n\n\n","category":"function"},{"location":"functions/#ntrapezohedron","page":"Functions","title":"ntrapezohedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ntrapezohedron","category":"page"},{"location":"functions/#Comodo.ntrapezohedron","page":"Functions","title":"Comodo.ntrapezohedron","text":"ntrapezohedron(n,r=1.0)\n\nConstructs an n-trapezohedron\n\nDescription\n\nThis function creates the faces F and vertices V for an n-trapezohedron. \n\nThe implementation is based on the equations presented here:  https://mathworld.wolfram.com/Trapezohedron.html\n\n\n\n\n\n","category":"function"},{"location":"functions/#spacing2numvertices","page":"Functions","title":"spacing2numvertices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.spacing2numvertices","category":"page"},{"location":"functions/#Comodo.spacing2numvertices","page":"Functions","title":"Comodo.spacing2numvertices","text":"spacing2numvertices(F::Vector{TriangleFace{TF}},V::Vector{Point{ND,TV}},pointSpacing::TP) where TF<:Integer where ND where TV<:Real where TP<:Real\n\nPoint numbers from spacing\n\nDescription\n\nThis function helps to determine what number of vertices to resample a surface  with to obtain a desired point spacing. The input consists of in initial surface , defined by the faces F and the vertices V, and also the desired point  spacing pointSpacing. Next the function uses the surface Euler characteristic as well as knowledge of face area and point spacing changes for homogeneous  face splitting (e.g. via subtri), to determine the theoretical number of  pointsNV` a resampled surface should have to present with the desired point spacing. \n\n\n\n\n\n","category":"function"},{"location":"functions/#joingeom","page":"Functions","title":"joingeom","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.joingeom","category":"page"},{"location":"functions/#Comodo.joingeom","page":"Functions","title":"Comodo.joingeom","text":"joingeom(G...)\n\nJoins geometry\n\nDescription\n\nThis function joins geometry defined for instance by multiple face and vertex  sets into one such set. All geometry such be of the same type such that they can be joined. The input can for instance be n-sets of faces (or elemens) and  vertices e.g. appearing as inpus as: F1,V1,F2,V2,...,FN,VN.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#quadbox","page":"Functions","title":"quadbox","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.quadbox","category":"page"},{"location":"functions/#Comodo.quadbox","page":"Functions","title":"Comodo.quadbox","text":"quadbox(boxDim,boxEl)\n\nCreates quadrilateral box mesh\n\nDescription\n\nThis function uses the dimensions defined in boxDim, and the number of  elements listed for each direction in boxEl to create a quadrilateral mesh for  a box. The output consists of the faces F, the vertices V, and a face  labelling C (for the 6 sides of the box). \n\n\n\n\n\n","category":"function"},{"location":"functions/#tribox","page":"Functions","title":"tribox","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tribox","category":"page"},{"location":"functions/#Comodo.tribox","page":"Functions","title":"Comodo.tribox","text":"tribox(boxDim,pointSpacing)\n\nCreates triangulated box mesh\n\nDescription\n\nThis function uses the dimensions defined in boxDim, and the desired point spacing defined by pointSpacing, to create a triangulated mesh for a box.  The output consists of the faces F, the vertices V, and a face  labelling C (for the 6 sides of the box). \n\n\n\n\n\n","category":"function"},{"location":"functions/#tetbox","page":"Functions","title":"tetbox","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tetbox","category":"page"},{"location":"functions/#Comodo.tetbox","page":"Functions","title":"Comodo.tetbox","text":"tetbox(boxDim,pointSpacing; stringOpt = \"paAqYQ\",region_vol=nothing)\n\nCreates tetrahedral box mesh\n\nDescription\n\nThis function uses the dimensions defined in boxDim, and the desired point spacing defined by pointSpacing, to create a tetrahedral mesh for a box.  The output consists of the elements E, the vertices V, the boundary faces  Fb, and the boundary face labelling Cb (for the 6 sides of the box). \n\n\n\n\n\n","category":"function"},{"location":"#Comodo.jl","page":"Comodo.jl","title":"Comodo.jl","text":"","category":"section"},{"location":"","page":"Comodo.jl","title":"Comodo.jl","text":"___________________","category":"page"},{"location":"","page":"Comodo.jl","title":"Comodo.jl","text":"Functions","category":"page"}]
}
