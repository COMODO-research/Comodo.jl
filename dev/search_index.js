var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#comododir","page":"Functions","title":"comododir","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.comododir","category":"page"},{"location":"functions/#Comodo.comododir","page":"Functions","title":"Comodo.comododir","text":"comododir()\n\nDescription\n\nThis function simply returns the string for the Comodo path. This is helpful for instance to load items, such as meshes, from the assets` folder. \n\n\n\n\n\n","category":"function"},{"location":"functions/#slidercontrol","page":"Functions","title":"slidercontrol","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.slidercontrol","category":"page"},{"location":"functions/#Comodo.slidercontrol","page":"Functions","title":"Comodo.slidercontrol","text":"slidercontrol(hSlider,ax)\n\nAdds arrow key control to sliders\n\nDescription\n\nThis function adds arrow key control to GLMakie sliders. The inputs are the  slider handle hSlider as well as the axis ax. If this function is called the slider can be advanced a step by pressing the right arrow, and returned one step  by pressing the left arrow. When one presses and holds the right or left arrow  key, the slider will continue to move (as fast as graphics updating is possible on your system) up to the end or start slider position respectively. Users may  also use the up or down arrow keys. These function the same as the right and  left arrow keys, however, rather than stopping at the slider extrema, the  sliders position will \"wrap\" back to the start when advancing beyond the end  position, and vice versa. \n\n\n\n\n\n","category":"function"},{"location":"functions/#slider2anim","page":"Functions","title":"slider2anim","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.slider2anim","category":"page"},{"location":"functions/#Comodo.slider2anim","page":"Functions","title":"Comodo.slider2anim","text":"slider2anim(fig::Figure,hSlider::Slider,fileName::String; backforth=true, duration=2)\n\nExports movies from slider based visualisations.\n\nDescription\n\nConverts the effect of the slider defined by the slider handle hSlider for the  figure fig to an animation/movie file\n\n\n\n\n\n","category":"function"},{"location":"functions/#elements2indices","page":"Functions","title":"elements2indices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.elements2indices","category":"page"},{"location":"functions/#Comodo.elements2indices","page":"Functions","title":"Comodo.elements2indices","text":"elements2indices(F)\n\nReturns the indices contained in F\n\nDescription\n\nThis function obtains the unique set of indices for the vertices (nodes)  used by the the simplices defined by F. The vector F may contain any type of  simplices. For instance the elements in F may be of the type  GeometryBasics.TriangleFace or GeometryBasics.QuadFace (or any other) for  surface mesh data. However, volumetric elements of any type are permitted. In essence this function simply returns unique(reduce(vcat,F)). Hence any suitable vector containing vectors of numbers permitted by  reduce(vcat,F) is supported. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gridpoints","page":"Functions","title":"gridpoints","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gridpoints","category":"page"},{"location":"functions/#Comodo.gridpoints","page":"Functions","title":"Comodo.gridpoints","text":"gridpoints(x::Vector{T}, y=x, z=x) where T<:Real\n\nReturns 3D grids of points\n\nDescription\n\nThe gridpoints function returns a vector of 3D points which span a grid in 3D  space. Points are defined as per the input ranges or range vectors. The output  point vector contains elements of the type Point. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gridpoints_equilateral","page":"Functions","title":"gridpoints_equilateral","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gridpoints_equilateral","category":"page"},{"location":"functions/#Comodo.gridpoints_equilateral","page":"Functions","title":"Comodo.gridpoints_equilateral","text":"gridpoints_equilateral(xSpan,ySpan,pointSpacing::T; return_faces = false, rectangular=false) where T <: Real\n\nReturns a \"grid\" of 3D points that are located on the corners of an equilateral triangle tesselation.\n\nDescription\n\nThis function returns 3D point data in the form of a Vector{Point{3,Float64}}.  The point distribution is for an equilateral triangle tesselation. The input  consists of the span in the x-, and y-direction, i.e. xSpan and ySpan  respectively, as well as the desired pointSpacing. The \"spans\" should be  vectors or tuples defining the minimum and maximum coordinates for the grid. The true point spacing in the x-direction is computed such that a nearest whole  number of steps can cover the required distance. Next this spacing is used to  create the equilateral triangle point grid. Although the xSpan is closely  adhered to through this method, the ySpan is not fully covered. In the  y-direction the grid does start at the minimum level, but may stop short of  reaching the maximum y as it may not be reachable in a whole number of steps  from the minimum. Optional arguments include return_faces (default is  false), which will cause the function to return triangular faces F as well  as the vertices V. Secondly the option rectangular will force the grid to  conform to a rectangular domain. This means the \"jagged\" sides are forced to be  flat such that all x-coordinates on the left are at the minimum in xSpan and all on the right are at the maximum in xSpan, however, this does result in a  non-uniform spacing at these edges.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#interp_biharmonic_spline","page":"Functions","title":"interp_biharmonic_spline","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.interp_biharmonic_spline","category":"page"},{"location":"functions/#Comodo.interp_biharmonic_spline","page":"Functions","title":"Comodo.interp_biharmonic_spline","text":"interp_biharmonic_spline(x::Union{Vector{T}, AbstractRange{T}},y::Union{Vector{T}, AbstractRange{T}},xi::Union{Vector{T}, AbstractRange{T}}; extrapolate_method=:linear,pad_data=:linear) where T<:Real\n\nInterpolates 1D (curve) data using biharmonic spline interpolation\n\nDescription\n\nThis function uses biharmonic spline interpolation [1], which features radial basis  functions. The input is assumed to represent ordered data, i.e. consequtive  unique points on a curve. The curve x-, and y-coordinates are provided through  the input parameters x and y respectively. The third input xi defines the  sites at which to interpolate. Each of in the input parameters can be either a  vector or a range. \n\nReferences\n\nDavid T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139\n\n\n\n\n\n","category":"function"},{"location":"functions/#interp_biharmonic","page":"Functions","title":"interp_biharmonic","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.interp_biharmonic","category":"page"},{"location":"functions/#Comodo.interp_biharmonic","page":"Functions","title":"Comodo.interp_biharmonic","text":"interp_biharmonic(x,y,xi)\n\nInterpolates n-dimensional data using biharmonic spline interpolation\n\nDescription\n\nThis function uses biharmonic interpolation [1]. The input x should define a  vector consisting of m points which are n-dimensional, and the input y should be a vector consisting of m scalar data values. \n\nReferences\n\nDavid T. Sandwell, Biharmonic spline interpolation of GEOS-3 and SEASAT altimeter data, Geophysical Research Letters, 2, 139-142, 1987. doi: 10.1029/GL014i002p00139\n\n\n\n\n\n","category":"function"},{"location":"functions/#nbezier","page":"Functions","title":"nbezier","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.nbezier","category":"page"},{"location":"functions/#Comodo.nbezier","page":"Functions","title":"Comodo.nbezier","text":"nbezier(P,n)\n\nReturns a Bezier spline for the control points P whose order matches the numbe  of control points provided. \n\nDescription\n\nThis function returns n points for an m-th order Bézier spline, based on the  m control points contained in the input vector P. This function supports point vectors with elements of the type AbstractPoint{3} (e.g. Point{3, Float64}) or Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"functions/#lerp","page":"Functions","title":"lerp","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.lerp","category":"page"},{"location":"functions/#Comodo.lerp","page":"Functions","title":"Comodo.lerp","text":"lerp(x::Union{T,Vector{T}, AbstractRange{T}},y,xi::Union{T,Vector{T}, AbstractRange{T}}) where T <: Real\n\nLinear interpolation\n\nDescription\n\nThis linearly interpolates (lerps) the input data specified by the sites x and  data y at the specified sites xi. \n\n\n\n\n\n","category":"function"},{"location":"functions/#dist","page":"Functions","title":"dist","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.dist","category":"page"},{"location":"functions/#Comodo.dist","page":"Functions","title":"Comodo.dist","text":"dist(V1,V2)\n\nComputes n-dimensional Euclidean distances\n\nDescription\n\nFunction compute an nxm distance matrix for the n inputs points in V1, and the m input points in V2. The input points may be multidimensional, in fact they can be any type supported by the euclidean function of Distances.jl.  See also: https://github.com/JuliaStats/Distances.jl\n\n\n\n\n\n","category":"function"},{"location":"functions/#mindist","page":"Functions","title":"mindist","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.mindist","category":"page"},{"location":"functions/#Comodo.mindist","page":"Functions","title":"Comodo.mindist","text":"mindist(V1,V2; getIndex=false, skipSelf = false )\n\nReturns nearest point distances \n\nDescription\n\nReturns the closest point distance for the input points V1 with respect to the  input points V2. If the optional parameter getIndex is set to true (false  by default) then this function also returns the indices of the nearest points  in V2 for each point in V1. For self-distance evaluation, i.e. if the same  point set is provided twice, then the optional parameter skipSelf can be set  t0 true (default is false) if \"self distances\" (e.g. the nth point to the  nth point) are to be avoided.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index","page":"Functions","title":"unique_dict_index","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index","category":"page"},{"location":"functions/#Comodo.unique_dict_index","page":"Functions","title":"Comodo.unique_dict_index","text":"unique_dict_index(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T <: Any\n\nReturns unique values and indices\n\nDescription\n\nReturns the unique entries in X as well as the indices for them.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index_inverse","page":"Functions","title":"unique_dict_index_inverse","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index_inverse","category":"page"},{"location":"functions/#Comodo.unique_dict_index_inverse","page":"Functions","title":"Comodo.unique_dict_index_inverse","text":"unique_dict_index_inverse(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T <: Any\n\nReturns unique values, indices, and inverse indices\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the  reverse indices to retrieve the original from the unique entries.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index_count","page":"Functions","title":"unique_dict_index_count","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index_count","category":"page"},{"location":"functions/#Comodo.unique_dict_index_count","page":"Functions","title":"Comodo.unique_dict_index_count","text":"unique_dict_index_count(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T <: Any\n\nReturns unique values, indices, and counts\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the counts  in terms of how often they occured.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_index_inverse_count","page":"Functions","title":"unique_dict_index_inverse_count","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_index_inverse_count","category":"page"},{"location":"functions/#Comodo.unique_dict_index_inverse_count","page":"Functions","title":"Comodo.unique_dict_index_inverse_count","text":"unique_dict_index_inverse_count(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T <: Any\n\nReturns unique values, indices, inverse indices, and counts\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the reverse  indices to retrieve the original from the unique entries, and also the counts in  terms of how often they occured.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_count","page":"Functions","title":"unique_dict_count","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_count","category":"page"},{"location":"functions/#Comodo.unique_dict_count","page":"Functions","title":"Comodo.unique_dict_count","text":"unique_dict_count(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T <: Any\n\nReturns unique values and counts\n\nDescription\n\nReturns the unique entries in X as well as the counts in terms of how often  they occured.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict_inverse","page":"Functions","title":"unique_dict_inverse","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict_inverse","category":"page"},{"location":"functions/#Comodo.unique_dict_inverse","page":"Functions","title":"Comodo.unique_dict_inverse","text":"unique_dict_inverse(X::Union{Array{T},Tuple{T}}; sort_entries=false) where T <: Any\n\nReturns unique values and inverse indices\n\nDescription\n\nReturns the unique entries in X as well as the reverse indices to retrieve the  original from the unique entries.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_dict","page":"Functions","title":"unique_dict","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_dict","category":"page"},{"location":"functions/#Comodo.unique_dict","page":"Functions","title":"Comodo.unique_dict","text":"unique_dict(X::AbstractVector{T}) where T <: Real\n\nReturns unique values, indices, and inverse indices. Uses an OrderedDict.\n\nDescription\n\nReturns the unique entries in X as well as the indices for them and the reverse  indices to retrieve the original from the unique entries. \n\n\n\n\n\n","category":"function"},{"location":"functions/#gunique","page":"Functions","title":"gunique","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.gunique","category":"page"},{"location":"functions/#Comodo.gunique","page":"Functions","title":"Comodo.gunique","text":"gunique(X; return_unique=true, return_index=false, return_inverse=false, return_counts=false, sort_entries=false)\n\nReturns unique values and allows users to choose if they also want: sorting, indices, inverse indices, and counts. \n\nDescription\n\nReturns the unique entries in X. Depending on the optional parameter choices the indices for the unique entries, the reverse indices to retrieve the original from the unique entries, as well as counts in terms of how often they occured,  can be returned.  The optional parameter sort_entries (default is false) can be set to true if each entry in X should be sorted, this is helpful to allow the entry [1,2] to  be seen as the same as [2,1] for instance.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#unique_simplices","page":"Functions","title":"unique_simplices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.unique_simplices","category":"page"},{"location":"functions/#Comodo.unique_simplices","page":"Functions","title":"Comodo.unique_simplices","text":"unique_simplices(F,V=nothing)\n\nReturns unique simplices (such as faces), independant of node order\n\nDescription\n\nReturns the unique simplices in F as well as the indices of the unique simplices and the reverse indices to retrieve the original faces from the unique faces.  Entries in F are sorted such that the node order does not matter. \n\n\n\n\n\n","category":"function"},{"location":"functions/#ind2sub","page":"Functions","title":"ind2sub","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ind2sub","category":"page"},{"location":"functions/#Comodo.ind2sub","page":"Functions","title":"Comodo.ind2sub","text":"ind2sub(siz,ind)\n\nConverts linear indices to subscript indices. \n\nDescription\n\nConverts the linear indices in ind, for a matrix/array with size siz, to the  equivalent subscript indices.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#sub2ind","page":"Functions","title":"sub2ind","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.sub2ind","category":"page"},{"location":"functions/#Comodo.sub2ind","page":"Functions","title":"Comodo.sub2ind","text":"sub2ind(siz,A)\n\nConverts subscript indices to linear indices. \n\nDescription\n\nConverts the subscript indices in A, for a matrix/array with size siz, to  the equivalent linear indices.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#meshedges","page":"Functions","title":"meshedges","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.meshedges","category":"page"},{"location":"functions/#Comodo.meshedges","page":"Functions","title":"Comodo.meshedges","text":"meshedges(F::Array{NgonFace{N,T},1}; unique_only=false) where N where T<:Integer\n\nReturns a mesh's edges.\n\nDescription\n\nThis function returns the edges E for the input faces defined by F.  The input F can either represent a vector of faces or a  GeometryBasics.Mesh. The convention is such that for a face referring to the  nodes 1-2-3-4, the edges are 1-2, 2-3, 3-4, 4-1.   \n\n\n\n\n\n","category":"function"},{"location":"functions/#icosahedron","page":"Functions","title":"icosahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.icosahedron","category":"page"},{"location":"functions/#Comodo.icosahedron","page":"Functions","title":"Comodo.icosahedron","text":"icosahedron(r=1.0)\n\nCreates an icosahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an icosahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#octahedron","page":"Functions","title":"octahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.octahedron","category":"page"},{"location":"functions/#Comodo.octahedron","page":"Functions","title":"Comodo.octahedron","text":"octahedron(r=1.0)\n\nCreates an octahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an octahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#dodecahedron","page":"Functions","title":"dodecahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.dodecahedron","category":"page"},{"location":"functions/#Comodo.dodecahedron","page":"Functions","title":"Comodo.dodecahedron","text":"dodecahedron(r=1.0)\n\nCreates a dodecahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an dodecahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#cube","page":"Functions","title":"cube","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.cube","category":"page"},{"location":"functions/#Comodo.cube","page":"Functions","title":"Comodo.cube","text":"cube(r=1.0)\n\nCreates a cube mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an cube with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#tetrahedron","page":"Functions","title":"tetrahedron","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tetrahedron","category":"page"},{"location":"functions/#Comodo.tetrahedron","page":"Functions","title":"Comodo.tetrahedron","text":"tetrahedron(r=1.0)\n\nCreates a tetrahedron mesh. \n\nDescription\n\nCreates a GeometryBasics.Mesh for an tetrahedron with radius r. The default  radius, when not supplied, is 1.0. \n\n\n\n\n\n","category":"function"},{"location":"functions/#platonicsolid","page":"Functions","title":"platonicsolid","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.platonicsolid","category":"page"},{"location":"functions/#Comodo.platonicsolid","page":"Functions","title":"Comodo.platonicsolid","text":"platonicsolid(n,r=1.0)\n\nReturns a platonic solid mesh.\n\nDescription\n\nCreates a GeometryBasics mesh description for a platonic solid of choice. The  input n defines the choice.\n\ntetrahedron\ncube\noctahedron\nicosahedron\ndodecahedron\n\nThe final input parameter r defines the radius of the platonic solid (the  radius of the circumsphere to the vertices).  The default radius, when not  supplied, is 1.0. \n\nArguments\n\nn::Integer, defining platonic solid type r::Float64, defining circumsphere radius\n\n\n\n\n\n","category":"function"},{"location":"functions/#tofaces","page":"Functions","title":"tofaces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tofaces","category":"page"},{"location":"functions/#Comodo.tofaces","page":"Functions","title":"Comodo.tofaces","text":"tofaces(FM::Vector{Vector{TF}}) where TF<:Integer\ntofaces(FM::Matrix{TF})  where TF<:Integer\ntofaces(FM::Vector{NgonFace{m, OffsetInteger{-1, TF}}} ) where m where TF <: Integer\ntofaces(FM::Vector{NgonFace{m, TF}} ) where m where TF <: Integer\n\nConverts input to GeometryBasics compliant faces with standard integer types. \n\nDescription\n\nThe tofaces function converts \"non-standard\" (for Comodo) face set  descriptions to \"standard\" ones. The following is considered such as standard:  Vector{GeometryBasics.NgonFace{N,T}} where N where T<:Integer  The input faces FM are converted to this format. FM can be of the following  types: \n\nFM::Vector{Vector{TF}} where TF<:Integer, whereby each Vector entry is \n\nconsidered a face\n\nFM::Matrix{TF} where TF<:Integer, whereby each row is considered a face\nVector{NgonFace{m, OffsetInteger{-1, TF}}} where TF<:Integer, whereby the \n\nspecial integer type OffsetInteger{-1, TF} is converted to Int64.   If the intput is already of the right type this function leaves the input  unchanged.\n\n\n\n\n\n","category":"function"},{"location":"functions/#topoints","page":"Functions","title":"topoints","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.topoints","category":"page"},{"location":"functions/#Comodo.topoints","page":"Functions","title":"Comodo.topoints","text":"topoints(VM::Matrix{T}) where T<: Real\ntopoints(VM::Union{Array{Vec{N, T}, 1}, GeometryBasics.StructArray{TT,1} }) where TT <: AbstractPoint{N,T} where T <: Real where N   \ntopoints(VM::Vector{Vector{T}}) where T <: Real  \ntopoints(VM::Vector{Point{ND,TV}}) where ND where TV <: Real\n\nConverts input to GeometryBasics compliant simple points without meta content.\n\nDescription\n\nThe topoints function converts the \"non-standard\" (for Comodo) input points  defined by VM to the \"standard\" format: VM::Vector{Point{ND,TV}} where ND where TV <: Real. For matrix input each row is considered a point. For vector input each vector  entry is considered a point.     \n\n\n\n\n\n","category":"function"},{"location":"functions/#togeometrybasics_mesh","page":"Functions","title":"togeometrybasics_mesh","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.togeometrybasics_mesh","category":"page"},{"location":"functions/#Comodo.togeometrybasics_mesh","page":"Functions","title":"Comodo.togeometrybasics_mesh","text":"togeometrybasics_mesh\n\nConverts the input to a GeometryBasics.Mesh\n\nDescription\n\nThis function converts the input faces F and vertices V to a  GeometryBasics.Mesh. The function tofaces and topoints are used prior to  conversion, to ensure standard faces and point types are used. \n\n\n\n\n\n","category":"function"},{"location":"functions/#edgecrossproduct","page":"Functions","title":"edgecrossproduct","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.edgecrossproduct","category":"page"},{"location":"functions/#Comodo.edgecrossproduct","page":"Functions","title":"Comodo.edgecrossproduct","text":"edgecrossproduct(F,V::Vector{Point{ND,T}}) where ND where T<:Real  \nedgecrossproduct(M::GeometryBasics.Mesh)\n\nReturns the edge cross product, useful for nomal direction and area computations. \n\n# Description\n\nThis function computes the so-called edge-cross-product for a input mesh that is either defined by the faces F and vertices V or the mesh M. \n\n\n\n\n\n","category":"function"},{"location":"functions/#facenormal","page":"Functions","title":"facenormal","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.facenormal","category":"page"},{"location":"functions/#Comodo.facenormal","page":"Functions","title":"Comodo.facenormal","text":"facenormal(F,V; weighting=:area)\n\nReturns the normal directions for each face.\n\nDescription\n\nThis function computes the per face normal directions for the input mesh defined  either by the faces F and vertices V or by the GeometryBasics mesh M. \n\n\n\n\n\n","category":"function"},{"location":"functions/#facearea","page":"Functions","title":"facearea","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.facearea","category":"page"},{"location":"functions/#Comodo.facearea","page":"Functions","title":"Comodo.facearea","text":"facearea(F,V)\n\nReturns the area for each face. \n\nDescription\n\nThis function computes the per face area for the input mesh defined either by  the faces F and vertices V or by the GeometryBasics mesh M. \n\n\n\n\n\n","category":"function"},{"location":"functions/#vertexnormal","page":"Functions","title":"vertexnormal","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.vertexnormal","category":"page"},{"location":"functions/#Comodo.vertexnormal","page":"Functions","title":"Comodo.vertexnormal","text":"vertexnormal(F,V; weighting=:area)\n\nReturns the surface normal at each vertex.\n\nDescription\n\nThis function computes the per vertex surface normal directions for the input  mesh defined either by the faces F and vertices V or by the GeometryBasics mesh M. The optional parameter weighting sets how the face normal directions  are averaged onto the vertices. If weighting=:none a plain average for the  surrounding faces is used. If instead weighting=:area (default), then the average is weighted based on the face areas. \n\n\n\n\n\n","category":"function"},{"location":"functions/#edgelengths","page":"Functions","title":"edgelengths","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.edgelengths","category":"page"},{"location":"functions/#Comodo.edgelengths","page":"Functions","title":"Comodo.edgelengths","text":"edgelengths(E::LineFace,V)\nedgelengths(F,V)\nedgelengths(M::GeometryBasics.Mesh)\n\nReturns edge lengths.\n\nDescription\n\nThis function computes the lengths of the edges defined by edge vector E (e.g as obtained from meshedges(F,V), where F is a face vector, and V is a  vector of vertices.  Alternatively the input mesh can be a GeometryBasics mesh M.\n\n\n\n\n\n","category":"function"},{"location":"functions/#subtri","page":"Functions","title":"subtri","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subtri","category":"page"},{"location":"functions/#Comodo.subtri","page":"Functions","title":"Comodo.subtri","text":"subtri(F,V,n; method = :linear)\nsubtri(F,V,n; method = :Loop)\n\nRefines triangulations through splitting.\n\nDescription\n\nThe subtri function refines triangulated meshes iteratively. For each iteration each original input triangle is split into 4 triangles to form the refined mesh  (one central one, and 3 at each corner). The following refinement methods are  implemented: \n\nmethod=:linear : This is the default method, and refines the triangles in a  simple linear manor through splitting. Each input edge simply obtains a new  mid-edge node. \n\nmethod=:Loop : This method features Loop-subdivision [1,2]. Rather than linearly  splitting edges and maintaining the original coordinates, as for the linear  method, this method computes the new points in a special weighted sense such  that the surface effectively approaches a \"quartic box spline\". Hence this  method both refines and smoothes the geometry through spline approximation. \n\nReferences\n\nCharles Loop, Smooth Subdivision Surfaces Based on Triangles, M.S. Mathematics Thesis, University of Utah. 1987.\nJos Stam, Charles Loop, Quad/Triangle Subdivision, doi: 10.1111/1467-8659.t01-2-00647\n\n\n\n\n\n","category":"function"},{"location":"functions/#subquad","page":"Functions","title":"subquad","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subquad","category":"page"},{"location":"functions/#Comodo.subquad","page":"Functions","title":"Comodo.subquad","text":"subquad(F::Vector{NgonFace{4,TF}},V::Vector{Point{ND,TV}},n::Int64; method=:linear) where TF<:Integer where ND where TV <: Real subquad(F::Vector{NgonFace{4,TF}},V::Vector{Point{ND,TV}},n::Int64; method=:Catmull_Clark) where TF<:Integer where ND where TV <: Real\n\nRefines quadrangulations through splitting.\n\nDescription\n\nThe subquad function refines quad meshes iteratively. For each iteration each original input quad is split into 4 smaller quads to form the refined mesh.  The following refinement methods are implemented: \n\nmethod=:linear : This is the default method, and refines the quads in a  simple linear manor through splitting. Each input edge simply obtains a new  mid-edge node, and each face obtains a new central node. \n\nmethod=:Catmull_Clark : This method features Catmull_Clark-subdivision [1].  Rather than linearly splitting edges and maintaining the original coordinates,  as for the linear method, this method computes the new points in a special  weighted sense such that the surface effectively approaches a bicubic B-spline  surface. Hence this method both refines and smoothes the geometry through  spline approximation. \n\nReferences\n\nE. Catmull and J. Clark, Recursively generated B-spline surfaces on arbitrary topological meshes, Computer-Aided Design, vol. 10, no. 6, pp. 350-355, Nov. 1978, doi: 10.1016/0010-4485(78)90110-0.\n\n\n\n\n\n","category":"function"},{"location":"functions/#geosphere","page":"Functions","title":"geosphere","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.geosphere","category":"page"},{"location":"functions/#Comodo.geosphere","page":"Functions","title":"Comodo.geosphere","text":"geosphere(n::Int64,r::T) where T <: Real\n\nReturns a geodesic sphere triangulation\n\nDescription\n\nThis function returns a geodesic sphere triangulation based on the number of refinement iterations n and the radius r. Geodesic spheres (aka Buckminster-Fuller  spheres) are triangulations of a sphere that have near uniform edge lenghts.  The algorithm starts with a regular icosahedron. Next this icosahedron is refined  n times, while nodes are pushed to a sphere surface with radius r at each iteration. \n\n\n\n\n\n","category":"function"},{"location":"functions/#hexbox","page":"Functions","title":"hexbox","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.hexbox","category":"page"},{"location":"functions/#Comodo.hexbox","page":"Functions","title":"Comodo.hexbox","text":"hexbox(boxDim,boxEl)\n\nReturns a hexahedral mesh of a box\n\nDescription\n\nThis function returns a hexahedral mesh for a 3D rectangular box domain. \n\n\n\n\n\n","category":"function"},{"location":"functions/#smoothmesh_laplacian","page":"Functions","title":"smoothmesh_laplacian","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.smoothmesh_laplacian","category":"page"},{"location":"functions/#Comodo.smoothmesh_laplacian","page":"Functions","title":"Comodo.smoothmesh_laplacian","text":"smoothmesh_laplacian(F,V,con_V2V=nothing; n=1, λ=0.5)\n\nDescription\n\nThis function implements weighted Laplacian mesh smoothing. At each  iteration, this method replaces each point by an updated coordinate based on the  mean coordinates of that point's Laplacian umbrella. The update features a lerp like weighting between the previous iterations coordinates and the mean  coordinates. The code features Vs[q] = (1.0-λ).*Vs[q] .+ λ*mean(V[con_V2V[q]]) As can be seen, the weighting is controlled by the input parameter λ which is in the range (0,1). If λ=0 then no smoothing occurs. If λ=1 then pure  Laplacian mean based smoothing occurs. For intermediate values a linear blending between the two occurs.  \n\n\n\n\n\n","category":"function"},{"location":"functions/#smoothmesh_hc","page":"Functions","title":"smoothmesh_hc","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.smoothmesh_hc","category":"page"},{"location":"functions/#Comodo.smoothmesh_hc","page":"Functions","title":"Comodo.smoothmesh_hc","text":"smoothmesh_hc(F,V, con_V2V=nothing; n=1, α=0.1, β=0.5, tolDist=nothing)\n\nDescription\n\nThis function implements HC (Humphrey's Classes) smoothing [1]. This method uses Laplacian like smoothing but aims to compensate for shrinkage/swelling by also  \"pushing back\" towards the original coordinates. \n\nReference\n\nVollmer et al., Improved Laplacian Smoothing of Noisy Surface Meshes, 1999. doi: 10.1111/1467-8659.00334\n\n\n\n\n\n","category":"function"},{"location":"functions/#loflinear","page":"Functions","title":"loflinear","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.loftlinear","category":"page"},{"location":"functions/#Comodo.loftlinear","page":"Functions","title":"Comodo.loftlinear","text":"loftlinear(V1,V2;num_steps=2,close_loop=true,face_type=:tri)\n\nLoft a surface mesh between two input curves\n\nDescription\n\nThe loftlinear function spans a surface from input curve V1 to curve V2.  The surface is formed by \"lerping\" curves from V1 to V2 in num_loft  steps, and forming mesh faces between each curve. If close_loop==true then it is assumed the curves (and therefore the output surface mesh should be  closed over, i.e. that a connection should be made between each curve end and  start point. The user can request different face types for the output. The  default is face_type=:tri which will form isoceles triangles (or equilateral  triangles if the spacing is even) for a planar curve. The other face_type options supported are :quad (quadrilateral), and :tri_slash. For the  latter, triangles are formed by slashing the quads.  \n\nArguments:\n\nV1::Vector: n-vector \nV2::Vector: n-vector\n\n\n\n\n\n","category":"function"},{"location":"functions/#pointspacingmean","page":"Functions","title":"pointspacingmean","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.pointspacingmean","category":"page"},{"location":"functions/#Comodo.pointspacingmean","page":"Functions","title":"Comodo.pointspacingmean","text":"pointspacingmean(V::Vector{Point3{Float64}})\npointspacingmean(F::Array{NgonFace{N, Int64}, 1},V::Vector{Point3{Float64}}) where N\n\nThe pointspacingmean function computes the mean spacing between points. The  input can be just the coordinate set V, a vector of Point3  points, or also a set of edges E or faces F. If only V is provided it is  assumed that V represents an ordered set of \"adjacent\" points, e.g. as for a  curve. If a vector of edges E or a vector of faces F is also provided, then  the average edge length is computed. If instead a set of facesF` is provided  then edges are first computed after which the mean edge spacing is return. \n\n\n\n\n\n","category":"function"},{"location":"functions/#ray_triangle_intersect","page":"Functions","title":"ray_triangle_intersect","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.ray_triangle_intersect","category":"page"},{"location":"functions/#Comodo.ray_triangle_intersect","page":"Functions","title":"Comodo.ray_triangle_intersect","text":"ray_triangle_intersect(F::Vector{TriangleFace{Int64}},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))\nray_triangle_intersect(f::TriangleFace{Int64},V,ray_origin,ray_vector; rayType = :ray, triSide = 1, tolEps = eps(Float64))\n\nDescription\n\nThis function can compute triangle-ray or triangle-line intersections through  the use of the \"Möller-Trumbore triangle-ray intersection algorithm\" [1]. The  required inputs are as follows: \n\nF an single face or a vector of faces, e.g. Vector{TriangleFace{Int64}} V The triangle vertices as a vector of points, i.e. Vector{Point{3, Float64}} ray_vector The ray vector which can be Vector{Point{3, Float64}} or Vec3{Float64}\n\nThe following optional input parameters can be provided:  rayType = :ray (default) or :line. This defines wether the vector is treated as a ray (extends indefinately) or as a line (finite length) triSide = 1 (default) or 0 or -1.  When triSide=1 only the inward intersections are considered, e.g. when the ray or line enters the shape (ray/line is pointing against face normal) When triSide=-1 only the outward intersections are considered, e.g. when the ray or line exits the shape (ray/line is pointing allong face normal) When triSide=0 both inward and outward intersections are considered. tolEps = eps(Float64) (default) \n\nReferences\n\nMöller, Tomas; Trumbore, Ben (1997). Fast, Minimum Storage Ray-Triangle Intersection. Journal of Graphics Tools. 2: 21-28. doi: 10.1080/10867651.1997.10487468.\n\n\n\n\n\n","category":"function"},{"location":"functions/#mesh_curvature_polynomial","page":"Functions","title":"mesh_curvature_polynomial","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.mesh_curvature_polynomial","category":"page"},{"location":"functions/#Comodo.mesh_curvature_polynomial","page":"Functions","title":"Comodo.mesh_curvature_polynomial","text":"mesh_curvature_polynomial(F::Vector{TriangleFace{Int64}},V::Vector{Point3{Float64}})\nmesh_curvature_polynomial(M::GeometryBasics.Mesh)\n\nDescription\n\nThis function computes the mesh curvature at each vertex for the input mesh  defined by the face F and the vertices V. A local polynomial is fitted to  each point's \"Laplacian umbrella\" (point neighbourhood), and the curvature of  this fitted form is derived. Instead of the mesh faces and vertices one may  instead specify the GeometryBasics.Mesh M as the input. \n\nThe reference below [1] provides more detail on the algorithm. In addition, this  implementation was created with the help of this helpful document,  which features a nice overview of the theory/steps involved in this algorithm. \n\nReferences\n\nF. Cazals and M. Pouget, Estimating differential quantities using polynomial fitting of osculating jets, Computer Aided Geometric Design, vol. 22, no. 2, pp. 121-146, Feb. 2005, doi: 10.1016/j.cagd.2004.09.004\n\n\n\n\n\n","category":"function"},{"location":"functions/#separate_vertices","page":"Functions","title":"separate_vertices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.separate_vertices","category":"page"},{"location":"functions/#Comodo.separate_vertices","page":"Functions","title":"Comodo.separate_vertices","text":"separate_vertices(F::Array{NgonFace{N, Int64}, 1},V::Array{Point{M, T}, 1}) where N where M where T<:Real\nseparate_vertices(M::GeometryBasics.Mesh)\n\nThis function takes the input mesh defined by the faces F and vertices V and separates any shared vertices. It does this by giving each face its own set of  unshared vertices. Note that any unused points are not returned in the output  point array Vn. \n\n\n\n\n\n","category":"function"},{"location":"functions/#evenly_sample","page":"Functions","title":"evenly_sample","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.evenly_sample","category":"page"},{"location":"functions/#Comodo.evenly_sample","page":"Functions","title":"Comodo.evenly_sample","text":"evenly_sample(V::Vector{Point{ND,TV}}, n::Int64; rtol = 1e-8, niter = 1) where ND where TV<:Real\n\nEvenly samples curves. \n\nDescription\n\nThis function aims to evenly resample the input curve defined by the ND points  V using n points. The function returns the resampled points as well as the  spline interpolator S used. The output points can also be retriebed by using:  S.(range(0.0, 1.0, n)).  Note that the even sampling is defined in terms of the curve length for a 4th  order natural B-spline that interpolates the input data. Hence if significant  curvature exists for the B-spline between two adjacent data points then the  spacing between points in the output may be non-uniform (despite the allong  B-spline distance being uniform). \n\n\n\n\n\n","category":"function"},{"location":"functions/#invert_faces","page":"Functions","title":"invert_faces","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.invert_faces","category":"page"},{"location":"functions/#Comodo.invert_faces","page":"Functions","title":"Comodo.invert_faces","text":"invert_faces(F::Vector{NgonFace{N, TF}, 1}) where N where TF<:Integer\n\nFlips face orientations.\n\nDescription\n\nThis function inverts the faces in F, such that the face normal will be  flipped, by reversing the node order for each face. \n\n\n\n\n\n","category":"function"},{"location":"functions/#kabsch_rot","page":"Functions","title":"kabsch_rot","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.kabsch_rot","category":"page"},{"location":"functions/#Comodo.kabsch_rot","page":"Functions","title":"Comodo.kabsch_rot","text":"R = kabsch_rot(V1::Array{Point{N, T}, 1},V2::Array{Point{N, TT}, 1}) where N where T<:Real where TT<:Real\n\nDescription\n\nComputes the rotation tensor R to rotate the points in V1 to best match the  points in V2. \n\nReference\n\nWolfgang Kabsch, A solution for the best rotation to relate two sets of vectors, Acta Crystallographica Section A, vol. 32, no. 5, pp. 922-923, 1976, doi: 10.1107/S0567739476001873  https://en.wikipedia.org/wiki/Kabsch_algorithm \n\n\n\n\n\n","category":"function"},{"location":"functions/#sweeploft","page":"Functions","title":"sweeploft","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.sweeploft","category":"page"},{"location":"functions/#Comodo.sweeploft","page":"Functions","title":"Comodo.sweeploft","text":"F,V = sweeploft(Vc,V1,V2; face_type=:quad, num_twist = 0, close_loop=true)\n\nDescription\n\nThis function implements swept lofting. The start curve V1 is pulled allong the  guide curve Vc while also gradually (linearly) morphing into the end curve  V2.  The optional parameter face_type (default :quad) defines the type of mesh  faces uses. The same face types as loftlinear and extrudecurve are supported,  i.e. :quad, :tri_slash, tri, or quad2tri.  The optional parameter num_twist (default is 0) can be used to add an integer  number (negative or positive) of full twists to the loft.  Finally the optional parameter close_loop (default is true) determines if the section curves are deemed closed or open ended. \n\n\n\n\n\n","category":"function"},{"location":"functions/#revolvecurve","page":"Functions","title":"revolvecurve","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.revolvecurve","category":"page"},{"location":"functions/#Comodo.revolvecurve","page":"Functions","title":"Comodo.revolvecurve","text":"revolvecurve(Vc::Vector{Point{ND,TV}},θ=2.0*pi; s=0, n=Vec{3, Float64}(0.0,0.0,1.0),num_steps=nothing,close_loop=false,face_type=:quad)  where ND where TV<:Real\n\nRevolves curves to build surfaces \n\nDescription\n\nThis function rotates the curve Vc by the angle θ, in the direction s, around the vector n, to build the output mesh defined by the faces F and  vertices V. \n\n\n\n\n\n","category":"function"},{"location":"functions/#batman","page":"Functions","title":"batman","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.batman","category":"page"},{"location":"functions/#Comodo.batman","page":"Functions","title":"Comodo.batman","text":"batman(n::Int64)\n\nDescription\n\nThe batman function creates points on the curve for the Batman logo. The curve is useful for testing surface meshing algorithms since it contains sharp  transitions and pointy features. The user requests n points on the curve. The default forces exactly n points which may result in an assymetric curve. To  instead force symmetry the user can set the optional parameter symmetric=true.  In this case the output will be symmetric allong the y-axis, however the number of points on the curve may have increased (if the input n is not even). The second optional input is the direction of the curve, i.e. if it is clockwise,  dir=:cw or anti-clockwise dir=:acw.  The implementation is based on a \"parameterised Batman equation\" 1. The following modifications where made, the curve is here centered around  [0,0,0], scaled to be 2 in width, resampled evenly, and the default curve  direction is anti-clockwise. \n\nReferences\n\nhttps://www.desmos.com/calculator/ajnzwedvql\n\n\n\n\n\n","category":"function"},{"location":"functions/#tridisc","page":"Functions","title":"tridisc","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.tridisc","category":"page"},{"location":"functions/#Comodo.tridisc","page":"Functions","title":"Comodo.tridisc","text":"tridisc(r=1.0,n=0)\n\nDescription\n\nGenerates the faces F and vertices V for a triangulated disc (circle). The  algorithm starts with a triangulated hexagon (obtained if n=0) and uses  iterative subtriangulation circular coordinate correction to obtain the final  mesh. \n\n\n\n\n\n","category":"function"},{"location":"functions/#regiontrimesh","page":"Functions","title":"regiontrimesh","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.regiontrimesh","category":"page"},{"location":"functions/#Comodo.regiontrimesh","page":"Functions","title":"Comodo.regiontrimesh","text":"regiontrimesh(VT,R,P)\n\nDescription\n\nGenerates a multi-region triangle mesh for the input regions. The boundary  curves for all regions are containedin the tuple VT. Each region to be meshed is next defined using a tuple R containing indices into the curve typle VT.  If an entry in R contains only one index then the entire curve domain is  meshed. If R contains multiple indices then the first index is assumed to be  for the outer boundary curve, while all subsequent indices are for boundaries  defining holes in this region. \n\n\n\n\n\n","category":"function"},{"location":"functions/#scalesimplex","page":"Functions","title":"scalesimplex","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.scalesimplex","category":"page"},{"location":"functions/#Comodo.scalesimplex","page":"Functions","title":"Comodo.scalesimplex","text":"scalesimplex(F,V,s)\n\nScales faces (or general simplices) wrt their centre. \n\nDescription\n\nThis function scales each simplex (e.g. a face) wrt their centre (mean of  coordinates). This function is useful in generating lattice structures from  elements as well as to create visualisations whereby \"looking into\" the mesh is needed. \n\n\n\n\n\n","category":"function"},{"location":"functions/#subcurve","page":"Functions","title":"subcurve","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Comodo.subcurve","category":"page"},{"location":"functions/#Comodo.subcurve","page":"Functions","title":"Comodo.subcurve","text":"subcurve(V,n)\n\nAdds n points between each curve point.  \n\nDescription\n\nThis function adds n points between each current point on the curve V.\n\n\n\n\n\n","category":"function"},{"location":"#Comodo.jl","page":"Comodo.jl","title":"Comodo.jl","text":"","category":"section"},{"location":"","page":"Comodo.jl","title":"Comodo.jl","text":"___________________","category":"page"},{"location":"","page":"Comodo.jl","title":"Comodo.jl","text":"Functions","category":"page"}]
}
